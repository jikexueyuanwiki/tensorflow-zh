
\section{Constants, Sequences, and Random Values} \label{const_seq_rnd}

\footnote{Note: Functions taking Tensor arguments can also take anything accepted by tf.convert_to_tensor.}

\subsection{Contents}\label{contents}

\subsubsection{\texorpdfstring{\protect\hyperlink{AUTOGENERATED-constants--sequences--and-random-values}{Constants,
Sequences, and Random
Values}}{Constants, Sequences, and Random Values}}\label{constants-sequences-and-random-values-1}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{AUTOGENERATED-constant-value-tensors}{Constant
  Value Tensors}
\item
  \protect\hyperlink{zeros}{\texttt{tf.zeros(shape,\ dtype=tf.float32,\ name=None)}}
\item
  \protect\hyperlink{zerosux5flike}{\texttt{tf.zeros\_like(tensor,\ dtype=None,\ name=None)}}
\item
  \protect\hyperlink{ones}{\texttt{tf.ones(shape,\ dtype=tf.float32,\ name=None)}}
\item
  \protect\hyperlink{onesux5flike}{\texttt{tf.ones\_like(tensor,\ dtype=None,\ name=None)}}
\item
  \protect\hyperlink{fill}{\texttt{tf.fill(dims,\ value,\ name=None)}}
\item
  \protect\hyperlink{constant}{\texttt{tf.constant(value,\ dtype=None,\ shape=None,\ name=\textquotesingle{}Const\textquotesingle{})}}
\item
  \protect\hyperlink{AUTOGENERATED-sequences}{Sequences}
\item
  \protect\hyperlink{linspace}{\texttt{tf.linspace(start,\ stop,\ num,\ name=None)}}
\item
  \protect\hyperlink{range}{\texttt{tf.range(start,\ limit,\ delta=1,\ name=\textquotesingle{}range\textquotesingle{})}}
\item
  \protect\hyperlink{AUTOGENERATED-random-tensors}{Random Tensors}
\item
  \protect\hyperlink{AUTOGENERATED-examples-}{Examples:}
\item
  \protect\hyperlink{randomux5fnormal}{\texttt{tf.random\_normal(shape,\ mean=0.0,\ stddev=1.0,\ dtype=tf.float32,\ seed=None,\ name=None)}}
\item
  \protect\hyperlink{truncatedux5fnormal}{\texttt{tf.truncated\_normal(shape,\ mean=0.0,\ stddev=1.0,\ dtype=tf.float32,\ seed=None,\ name=None)}}
\item
  \protect\hyperlink{randomux5funiform}{\texttt{tf.random\_uniform(shape,\ minval=0.0,\ maxval=1.0,\ dtype=tf.float32,\ seed=None,\ name=None)}}
\item
  \protect\hyperlink{randomux5fshuffle}{\texttt{tf.random\_shuffle(value,\ seed=None,\ name=None)}}
\item
  \protect\hyperlink{setux5frandomux5fseed}{\texttt{tf.set\_random\_seed(seed)}}
\end{itemize}

\subsection{Constant Value Tensors }\label{constant-value-tensors}

TensorFlow provides several operations that you can use to generate
constants.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.zeros(shape,\ dtype=tf.float32,\ name=None)}
}{tf.zeros(shape, dtype=tf.float32, name=None) }}\label{tf.zerosshape-dtypetf.float32-namenone}

Creates a tensor with all elements set to zero.

This operation returns a tensor of type \texttt{dtype} with shape
\texttt{shape} and all elements set to zero.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tf.zeros([}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{], int32) }\OperatorTok{==>} \NormalTok{[[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{], [}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{], [}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args}

\begin{itemize}
\tightlist
\item
  \texttt{shape}: Either a list of integers, or a 1-D \texttt{Tensor} of
  type \texttt{int32}.
\item
  \texttt{dtype}: The type of an element in the resulting
  \texttt{Tensor}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns}

A \texttt{Tensor} with all elements set to zero.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.zeros\_like(tensor,\ dtype=None,\ name=None)}
}{tf.zeros\_like(tensor, dtype=None, name=None) }}\label{tf.zerosux5fliketensor-dtypenone-namenone}

Creates a tensor with all elements set to zero.

Given a single tensor (\texttt{tensor}), this operation returns a tensor
of the same type and shape as \texttt{tensor} with all elements set to
zero. Optionally, you can use \texttt{dtype} to specify a new type for
the returned tensor.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# 'tensor' is [[1, 2, 3], [4, 5, 6]]}
\NormalTok{tf.zeros_like(tensor) }\OperatorTok{==>} \NormalTok{[[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{], [}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-1}

\begin{itemize}
\item
  \texttt{tensor}: A \texttt{Tensor}.
\item
  \texttt{dtype}: A type for the returned \texttt{Tensor}. Must be
  \texttt{float32}, \texttt{float64}, \texttt{int8}, \texttt{int16},
  \texttt{int32}, \texttt{int64}, \texttt{uint8}, or \texttt{complex64}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-1}

A \texttt{Tensor} with all elements set to zero.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.ones(shape,\ dtype=tf.float32,\ name=None)}
}{tf.ones(shape, dtype=tf.float32, name=None) }}\label{tf.onesshape-dtypetf.float32-namenone}

Creates a tensor with all elements set to 1.

This operation returns a tensor of type \texttt{dtype} with shape
\texttt{shape} and all elements set to 1.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tf.ones([}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], int32) }\OperatorTok{==>} \NormalTok{[[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{], [}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-2}

\begin{itemize}
\tightlist
\item
  \texttt{shape}: Either a list of integers, or a 1-D \texttt{Tensor} of
  type \texttt{int32}.
\item
  \texttt{dtype}: The type of an element in the resulting
  \texttt{Tensor}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-2}

A \texttt{Tensor} with all elements set to 1.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.ones\_like(tensor,\ dtype=None,\ name=None)}
}{tf.ones\_like(tensor, dtype=None, name=None) }}\label{tf.onesux5fliketensor-dtypenone-namenone}

Creates a tensor with all elements set to 1.

Given a single tensor (\texttt{tensor}), this operation returns a tensor
of the same type and shape as \texttt{tensor} with all elements set to
1. Optionally, you can specify a new type (\texttt{dtype}) for the
returned tensor.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# 'tensor' is [[1, 2, 3], [4, 5, 6]]}
\NormalTok{tf.ones_like(tensor) }\OperatorTok{==>} \NormalTok{[[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{], [}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-3}

\begin{itemize}
\item
  \texttt{tensor}: A \texttt{Tensor}.
\item
  \texttt{dtype}: A type for the returned \texttt{Tensor}. Must be
  \texttt{float32}, \texttt{float64}, \texttt{int8}, \texttt{int16},
  \texttt{int32}, \texttt{int64}, \texttt{uint8}, or \texttt{complex64}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-3}

A \texttt{Tensor} with all elements set to 1.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.fill(dims,\ value,\ name=None)}
}{tf.fill(dims, value, name=None) }}\label{tf.filldims-value-namenone}

Creates a tensor filled with a scalar value.

This operation creates a tensor of shape \texttt{dims} and fills it with
\texttt{value}.

For example:

\begin{verbatim}
# output tensor shape needs to be [2, 3]
# so 'dims' is [2, 3]
fill(dims, 9) ==> [[9, 9, 9]
                   [9, 9, 9]]
\end{verbatim}

\subparagraph{Args: }\label{args-4}

\begin{itemize}
\tightlist
\item
  \texttt{dims}: A \texttt{Tensor} of type \texttt{int32}. 1-D.
  Represents the shape of the output tensor.
\item
  \texttt{value}: A \texttt{Tensor}. 0-D (scalar). Value to fill the
  returned tensor.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-4}

A \texttt{Tensor}. Has the same type as \texttt{value}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.constant(value,\ dtype=None,\ shape=None,\ name=\textquotesingle{}Const\textquotesingle{})}
}{tf.constant(value, dtype=None, shape=None, name='Const') }}\label{tf.constantvalue-dtypenone-shapenone-nameconst}

Creates a constant tensor.

The resulting tensor is populated with values of type \texttt{dtype}, as
specified by arguments \texttt{value} and (optionally) \texttt{shape}
(see examples below).

The argument \texttt{value} can be a constant value, or a list of values
of type \texttt{dtype}. If \texttt{value} is a list, then the length of
the list must be less than or equal to the number of elements implied by
the \texttt{shape} argument (if specified). In the case where the list
length is less than the number of elements specified by \texttt{shape},
the last element in the list will be used to fill the remaining entries.

The argument \texttt{shape} is optional. If present, it specifies the
dimensions of the resulting tensor. If not present, then the tensor is a
scalar (0-D) if \texttt{value} is a scalar, or 1-D otherwise.

If the argument \texttt{dtype} is not specified, then the type is
inferred from the type of \texttt{value}.

For example:

```python \# Constant 1-D Tensor populated with value list. tensor =
tf.constant({[}1, 2, 3, 4, 5, 6, 7{]}) =\textgreater{} {[}1 2 3 4 5 6
7{]}

\# Constant 2-D tensor populated with scalar value -1. tensor =
tf.constant(-1.0, shape={[}2, 3{]}) =\textgreater{} {[}{[}-1. -1.
-1.{]}{[}-1. -1. -1.{]}{]} ```

\subparagraph{Args: }\label{args-5}

\begin{itemize}
\item
  \texttt{value}: A constant value (or list) of output type
  \texttt{dtype}.
\item
  \texttt{dtype}: The type of the elements of the resulting tensor.
\item
  \texttt{shape}: Optional dimensions of resulting tensor.
\item
  \texttt{name}: Optional name for the tensor.
\end{itemize}

\subparagraph{Returns: }\label{returns-5}

A Constant Tensor.

\subsection{Sequences }\label{sequences}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.linspace(start,\ stop,\ num,\ name=None)}
}{tf.linspace(start, stop, num, name=None) }}\label{tf.linspacestart-stop-num-namenone}

Generates values in an interval.

A sequence of \texttt{num} evenly-spaced values are generated beginning
at \texttt{start}. If \texttt{num\ \textgreater{}\ 1}, the values in the
sequence increase by \texttt{stop\ -\ start\ /\ num\ -\ 1}, so that the
last one is exactly \texttt{stop}.

For example:

\begin{verbatim}
tf.linspace(10.0, 12.0, 3, name="linspace") => [ 10.0  11.0  12.0]
\end{verbatim}

\subparagraph{Args: }\label{args-6}

\begin{itemize}
\tightlist
\item
  \texttt{start}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}. First entry in the range.
\item
  \texttt{stop}: A \texttt{Tensor}. Must have the same type as
  \texttt{start}. Last entry in the range.
\item
  \texttt{num}: A \texttt{Tensor} of type \texttt{int32}. Number of
  values to generate.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-6}

A \texttt{Tensor}. Has the same type as \texttt{start}. 1-D. The
generated values.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.range(start,\ limit,\ delta=1,\ name=\textquotesingle{}range\textquotesingle{})}
}{tf.range(start, limit, delta=1, name='range') }}\label{tf.rangestart-limit-delta1-namerange}

Creates a sequence of integers.

This operation creates a sequence of integers that begins at
\texttt{start} and extends by increments of \texttt{delta} up to but not
including \texttt{limit}.

For example:

\begin{verbatim}
# 'start' is 3
# 'limit' is 18
# 'delta' is 3
tf.range(start, limit, delta) ==> [3, 6, 9, 12, 15]
\end{verbatim}

\subparagraph{Args: }\label{args-7}

\begin{itemize}
\tightlist
\item
  \texttt{start}: A 0-D (scalar) of type \texttt{int32}. First entry in
  sequence.
\item
  \texttt{limit}: A 0-D (scalar) of type \texttt{int32}. Upper limit of
  sequence, exclusive.
\item
  \texttt{delta}: A 0-D \texttt{Tensor} (scalar) of type \texttt{int32}.
  Optional. Default is 1. Number that increments \texttt{start}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-7}

An 1-D \texttt{int32} \texttt{Tensor}.

\subsection{Random Tensors }\label{random-tensors}

TensorFlow has several ops that create random tensors with different
distributions. The random ops are stateful, and create new random values
each time they are evaluated.

The \texttt{seed} keyword argument in these functions acts in
conjunction with the graph-level random seed. Changing either the
graph-level seed using
\href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
or the op-level seed will change the underlying seed of these
operations. Setting neither graph-level nor op-level seed, results in a
random seed for all operations. See
\href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
for details on the interaction between operation-level and graph-level
random seeds.

\subsubsection{Examples: }\label{examples}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a tensor of shape [2, 3] consisting of random normal values, with mean}
\CommentTok{# -1 and standard deviation 4.}
\NormalTok{norm }\OperatorTok{=} \NormalTok{tf.random_normal([}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], mean}\OperatorTok{=-}\DecValTok{1}\NormalTok{, stddev}\OperatorTok{=}\DecValTok{4}\NormalTok{)}

\CommentTok{# Shuffle the first dimension of a tensor}
\NormalTok{c }\OperatorTok{=} \NormalTok{tf.constant([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{], [}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{], [}\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]])}
\NormalTok{shuff }\OperatorTok{=} \NormalTok{tf.random_shuffle(c)}

\CommentTok{# Each time we run these ops, different results are generated}
\NormalTok{sess }\OperatorTok{=} \NormalTok{tf.Session()}
\BuiltInTok{print} \NormalTok{sess.run(norm)}
\BuiltInTok{print} \NormalTok{sess.run(norm)}

\CommentTok{# Set an op-level seed to generate repeatable sequences across sessions.}
\NormalTok{c }\OperatorTok{=} \NormalTok{tf.constant([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{], [}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{], [}\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]])}
\NormalTok{sess }\OperatorTok{=} \NormalTok{tf.Session()}
\NormalTok{norm }\OperatorTok{=} \NormalTok{tf.random_normal(c, seed}\OperatorTok{=}\DecValTok{1234}\NormalTok{)}
\BuiltInTok{print} \NormalTok{sess.run(norm)}
\BuiltInTok{print} \NormalTok{sess.run(norm)}
\end{Highlighting}
\end{Shaded}

Another common use of random values is the intialization of variables.
Also see the \href{../../how_tos/variables/index.md}{Variables How To}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Use random uniform values in [0, 1) as the initializer for a variable of shape}
\CommentTok{# [2, 3]. The default type is float32.}
\NormalTok{var }\OperatorTok{=} \NormalTok{tf.Variable(tf.random_uniform([}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]), name}\OperatorTok{=}\StringTok{"var"}\NormalTok{)}
\NormalTok{init }\OperatorTok{=} \NormalTok{tf.initialize_all_variables()}

\NormalTok{sess }\OperatorTok{=} \NormalTok{tf.Session()}
\NormalTok{sess.run(init)}
\BuiltInTok{print} \NormalTok{sess.run(var)}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.random\_normal(shape,\ mean=0.0,\ stddev=1.0,\ dtype=tf.float32,\ seed=None,\ name=None)}
}{tf.random\_normal(shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None) }}\label{tf.randomux5fnormalshape-mean0.0-stddev1.0-dtypetf.float32-seednone-namenone}

Outputs random values from a normal distribution.

\subparagraph{Args: }\label{args-8}

\begin{itemize}
\tightlist
\item
  \texttt{shape}: A 1-D integer Tensor or Python array. The shape of the
  output tensor.
\item
  \texttt{mean}: A 0-D Tensor or Python value of type \texttt{dtype}.
  The mean of the normal distribution.
\item
  \texttt{stddev}: A 0-D Tensor or Python value of type \texttt{dtype}.
  The standard deviation of the normal distribution.
\item
  \texttt{dtype}: The type of the output.
\item
  \texttt{seed}: A Python integer. Used to create a random seed for the
  distribution. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
  for behavior.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-8}

A tensor of the specified shape filled with random normal values.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.truncated\_normal(shape,\ mean=0.0,\ stddev=1.0,\ dtype=tf.float32,\ seed=None,\ name=None)}
}{tf.truncated\_normal(shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None) }}\label{tf.truncatedux5fnormalshape-mean0.0-stddev1.0-dtypetf.float32-seednone-namenone}

Outputs random values from a truncated normal distribution.

The generated values follow a normal distribution with specified mean
and standard deviation, except that values whose magnitude is more than
2 standard deviations from the mean are dropped and re-picked.

\subparagraph{Args: }\label{args-9}

\begin{itemize}
\tightlist
\item
  \texttt{shape}: A 1-D integer Tensor or Python array. The shape of the
  output tensor.
\item
  \texttt{mean}: A 0-D Tensor or Python value of type \texttt{dtype}.
  The mean of the truncated normal distribution.
\item
  \texttt{stddev}: A 0-D Tensor or Python value of type \texttt{dtype}.
  The standard deviation of the truncated normal distribution.
\item
  \texttt{dtype}: The type of the output.
\item
  \texttt{seed}: A Python integer. Used to create a random seed for the
  distribution. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
  for behavior.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-9}

A tensor of the specified shape filled with random truncated normal
values.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.random\_uniform(shape,\ minval=0.0,\ maxval=1.0,\ dtype=tf.float32,\ seed=None,\ name=None)}
}{tf.random\_uniform(shape, minval=0.0, maxval=1.0, dtype=tf.float32, seed=None, name=None) }}\label{tf.randomux5funiformshape-minval0.0-maxval1.0-dtypetf.float32-seednone-namenone}

Outputs random values from a uniform distribution.

The generated values follow a uniform distribution in the range
\texttt{{[}minval,\ maxval)}. The lower bound \texttt{minval} is
included in the range, while the upper bound \texttt{maxval} is
excluded.

\subparagraph{Args: }\label{args-10}

\begin{itemize}
\tightlist
\item
  \texttt{shape}: A 1-D integer Tensor or Python array. The shape of the
  output tensor.
\item
  \texttt{minval}: A 0-D Tensor or Python value of type \texttt{dtype}.
  The lower bound on the range of random values to generate.
\item
  \texttt{maxval}: A 0-D Tensor or Python value of type \texttt{dtype}.
  The upper bound on the range of random values to generate.
\item
  \texttt{dtype}: The type of the output.
\item
  \texttt{seed}: A Python integer. Used to create a random seed for the
  distribution. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
  for behavior.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-10}

A tensor of the specified shape filled with random uniform values.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.random\_shuffle(value,\ seed=None,\ name=None)}
}{tf.random\_shuffle(value, seed=None, name=None) }}\label{tf.randomux5fshufflevalue-seednone-namenone}

Randomly shuffles a tensor along its first dimension.

The tensor is shuffled along dimension 0, such that each
\texttt{value{[}j{]}} is mapped to one and only one
\texttt{output{[}i{]}}. For example, a mapping that might occur for a
3x2 tensor is:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{],       [[}\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{],}
 \NormalTok{[}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{],  }\OperatorTok{==>}   \NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{],}
 \NormalTok{[}\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]]        [}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-11}

\begin{itemize}
\tightlist
\item
  \texttt{value}: A Tensor to be shuffled.
\item
  \texttt{seed}: A Python integer. Used to create a random seed for the
  distribution. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
  for behavior.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-11}

A tensor of same shape and type as \texttt{value}, shuffled along its
first dimension.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.set\_random\_seed(seed)}
}{tf.set\_random\_seed(seed) }}\label{tf.setux5frandomux5fseedseed}

Sets the graph-level random seed.

Operations that rely on a random seed actually derive it from two seeds:
the graph-level and operation-level seeds. This sets the graph-level
seed.

Its interactions with operation-level seeds is as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  If neither the graph-level nor the operation seed is set: A random
  seed is used for this op.
\item
  If the graph-level seed is set, but the operation seed is not: The
  system deterministically picks an operation seed in conjunction with
  the graph-level seed so that it gets a unique random sequence.
\item
  If the graph-level seed is not set, but the operation seed is set: A
  default graph-level seed and the specified operation seed are used to
  determine the random sequence.
\item
  If both the graph-level and the operation seed are set: Both seeds are
  used in conjunction to determine the random sequence.
\end{enumerate}

To illustrate the user-visible effects, consider these examples:

To generate different sequences across sessions, set neither graph-level
nor op-level seeds:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \NormalTok{tf.random_uniform([}\DecValTok{1}\NormalTok{])}
\NormalTok{b }\OperatorTok{=} \NormalTok{tf.random_normal([}\DecValTok{1}\NormalTok{])}

\BuiltInTok{print} \StringTok{"Session 1"}
\ControlFlowTok{with} \NormalTok{tf.Session() }\ImportTok{as} \NormalTok{sess1:}
  \BuiltInTok{print} \NormalTok{sess1.run(a)  }\CommentTok{# generates 'A1'}
  \BuiltInTok{print} \NormalTok{sess1.run(a)  }\CommentTok{# generates 'A2'}
  \BuiltInTok{print} \NormalTok{sess1.run(b)  }\CommentTok{# generates 'B1'}
  \BuiltInTok{print} \NormalTok{sess1.run(b)  }\CommentTok{# generates 'B2'}

\BuiltInTok{print} \StringTok{"Session 2"}
\ControlFlowTok{with} \NormalTok{tf.Session() }\ImportTok{as} \NormalTok{sess2:}
  \BuiltInTok{print} \NormalTok{sess2.run(a)  }\CommentTok{# generates 'A3'}
  \BuiltInTok{print} \NormalTok{sess2.run(a)  }\CommentTok{# generates 'A4'}
  \BuiltInTok{print} \NormalTok{sess2.run(b)  }\CommentTok{# generates 'B3'}
  \BuiltInTok{print} \NormalTok{sess2.run(b)  }\CommentTok{# generates 'B4'}
\end{Highlighting}
\end{Shaded}

To generate the same repeatable sequence for an op across sessions, set
the seed for the op:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \NormalTok{tf.random_uniform([}\DecValTok{1}\NormalTok{], seed}\OperatorTok{=}\DecValTok{1}\NormalTok{)}
\NormalTok{b }\OperatorTok{=} \NormalTok{tf.random_normal([}\DecValTok{1}\NormalTok{])}

\CommentTok{# Repeatedly running this block with the same graph will generate the same}
\CommentTok{# sequence of values for 'a', but different sequences of values for 'b'.}
\BuiltInTok{print} \StringTok{"Session 1"}
\ControlFlowTok{with} \NormalTok{tf.Session() }\ImportTok{as} \NormalTok{sess1:}
  \BuiltInTok{print} \NormalTok{sess1.run(a)  }\CommentTok{# generates 'A1'}
  \BuiltInTok{print} \NormalTok{sess1.run(a)  }\CommentTok{# generates 'A2'}
  \BuiltInTok{print} \NormalTok{sess1.run(b)  }\CommentTok{# generates 'B1'}
  \BuiltInTok{print} \NormalTok{sess1.run(b)  }\CommentTok{# generates 'B2'}

\BuiltInTok{print} \StringTok{"Session 2"}
\ControlFlowTok{with} \NormalTok{tf.Session() }\ImportTok{as} \NormalTok{sess2:}
  \BuiltInTok{print} \NormalTok{sess2.run(a)  }\CommentTok{# generates 'A1'}
  \BuiltInTok{print} \NormalTok{sess2.run(a)  }\CommentTok{# generates 'A2'}
  \BuiltInTok{print} \NormalTok{sess2.run(b)  }\CommentTok{# generates 'B3'}
  \BuiltInTok{print} \NormalTok{sess2.run(b)  }\CommentTok{# generates 'B4'}
\end{Highlighting}
\end{Shaded}

To make the random sequences generated by all ops be repeatable across
sessions, set a graph-level seed:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tf.set_random_seed(}\DecValTok{1234}\NormalTok{)}
\NormalTok{a }\OperatorTok{=} \NormalTok{tf.random_uniform([}\DecValTok{1}\NormalTok{])}
\NormalTok{b }\OperatorTok{=} \NormalTok{tf.random_normal([}\DecValTok{1}\NormalTok{])}

\CommentTok{# Repeatedly running this block with the same graph will generate different}
\CommentTok{# sequences of 'a' and 'b'.}
\BuiltInTok{print} \StringTok{"Session 1"}
\ControlFlowTok{with} \NormalTok{tf.Session() }\ImportTok{as} \NormalTok{sess1:}
  \BuiltInTok{print} \NormalTok{sess1.run(a)  }\CommentTok{# generates 'A1'}
  \BuiltInTok{print} \NormalTok{sess1.run(a)  }\CommentTok{# generates 'A2'}
  \BuiltInTok{print} \NormalTok{sess1.run(b)  }\CommentTok{# generates 'B1'}
  \BuiltInTok{print} \NormalTok{sess1.run(b)  }\CommentTok{# generates 'B2'}

\BuiltInTok{print} \StringTok{"Session 2"}
\ControlFlowTok{with} \NormalTok{tf.Session() }\ImportTok{as} \NormalTok{sess2:}
  \BuiltInTok{print} \NormalTok{sess2.run(a)  }\CommentTok{# generates 'A1'}
  \BuiltInTok{print} \NormalTok{sess2.run(a)  }\CommentTok{# generates 'A2'}
  \BuiltInTok{print} \NormalTok{sess2.run(b)  }\CommentTok{# generates 'B1'}
  \BuiltInTok{print} \NormalTok{sess2.run(b)  }\CommentTok{# generates 'B2'}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-12}

\begin{itemize}
\tightlist
\item
  \texttt{seed}: integer.
\end{itemize}


