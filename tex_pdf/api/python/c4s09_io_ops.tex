

\section{Inputs and Readers }\label{inputs-and-readers}

Note: Functions taking \texttt{Tensor} arguments can also take anything
accepted by
\href{../../api_docs/python/framework.md\#convert_to_tensor}{\texttt{tf.convert\_to\_tensor}}.

\subsection{Contents}\label{contents}

\subsubsection{\texorpdfstring{\protect\hyperlink{AUTOGENERATED-inputs-and-readers}{Inputs
and Readers}}{Inputs and Readers}}\label{inputs-and-readers-1}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{AUTOGENERATED-placeholders}{Placeholders}
\item
  \protect\hyperlink{placeholder}{\texttt{tf.placeholder(dtype,\ shape=None,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-readers}{Readers}
\item
  \protect\hyperlink{ReaderBase}{\texttt{class\ tf.ReaderBase}}
\item
  \protect\hyperlink{TextLineReader}{\texttt{class\ tf.TextLineReader}}
\item
  \protect\hyperlink{WholeFileReader}{\texttt{class\ tf.WholeFileReader}}
\item
  \protect\hyperlink{IdentityReader}{\texttt{class\ tf.IdentityReader}}
\item
  \protect\hyperlink{TFRecordReader}{\texttt{class\ tf.TFRecordReader}}
\item
  \protect\hyperlink{FixedLengthRecordReader}{\texttt{class\ tf.FixedLengthRecordReader}}
\item
  \protect\hyperlink{AUTOGENERATED-converting}{Converting}
\item
  \protect\hyperlink{decodeux5fcsv}{\texttt{tf.decode\_csv(records,\ record\_defaults,\ field\_delim=None,\ name=None)}}
\item
  \protect\hyperlink{decodeux5fraw}{\texttt{tf.decode\_raw(bytes,\ out\_type,\ little\_endian=None,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-example-protocol-buffer}{Example
  protocol buffer}
\item
  \protect\hyperlink{parseux5fexample}{\texttt{tf.parse\_example(serialized,\ names=None,\ sparse\_keys=None,\ sparse\_types=None,\ dense\_keys=None,\ dense\_types=None,\ dense\_defaults=None,\ dense\_shapes=None,\ name=\textquotesingle{}ParseExample\textquotesingle{})}}
\item
  \protect\hyperlink{parseux5fsingleux5fexample}{\texttt{tf.parse\_single\_example(serialized,\ names=None,\ sparse\_keys=None,\ sparse\_types=None,\ dense\_keys=None,\ dense\_types=None,\ dense\_defaults=None,\ dense\_shapes=None,\ name=\textquotesingle{}ParseSingleExample\textquotesingle{})}}
\item
  \protect\hyperlink{AUTOGENERATED-queues}{Queues}
\item
  \protect\hyperlink{QueueBase}{\texttt{class\ tf.QueueBase}}
\item
  \protect\hyperlink{FIFOQueue}{\texttt{class\ tf.FIFOQueue}}
\item
  \protect\hyperlink{RandomShuffleQueue}{\texttt{class\ tf.RandomShuffleQueue}}
\item
  \protect\hyperlink{AUTOGENERATED-dealing-with-the-filesystem}{Dealing
  with the filesystem}
\item
  \protect\hyperlink{matchingux5ffiles}{\texttt{tf.matching\_files(pattern,\ name=None)}}
\item
  \protect\hyperlink{readux5ffile}{\texttt{tf.read\_file(filename,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-input-pipeline}{Input pipeline}
\item
  \protect\hyperlink{AUTOGENERATED-beginning-of-an-input-pipeline}{Beginning
  of an input pipeline}
\item
  \protect\hyperlink{matchux5ffilenamesux5fonce}{\texttt{tf.train.match\_filenames\_once(pattern,\ name=None)}}
\item
  \protect\hyperlink{limitux5fepochs}{\texttt{tf.train.limit\_epochs(tensor,\ num\_epochs=None,\ name=None)}}
\item
  \protect\hyperlink{rangeux5finputux5fproducer}{\texttt{tf.train.range\_input\_producer(limit,\ num\_epochs=None,\ shuffle=True,\ seed=None,\ capacity=32,\ name=None)}}
\item
  \protect\hyperlink{sliceux5finputux5fproducer}{\texttt{tf.train.slice\_input\_producer(tensor\_list,\ num\_epochs=None,\ shuffle=True,\ seed=None,\ capacity=32,\ name=None)}}
\item
  \protect\hyperlink{stringux5finputux5fproducer}{\texttt{tf.train.string\_input\_producer(string\_tensor,\ num\_epochs=None,\ shuffle=True,\ seed=None,\ capacity=32,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-batching-at-the-end-of-an-input-pipeline}{Batching
  at the end of an input pipeline}
\item
  \protect\hyperlink{batch}{\texttt{tf.train.batch(tensor\_list,\ batch\_size,\ num\_threads=1,\ capacity=32,\ enqueue\_many=False,\ shapes=None,\ name=None)}}
\item
  \protect\hyperlink{batchux5fjoin}{\texttt{tf.train.batch\_join(tensor\_list\_list,\ batch\_size,\ capacity=32,\ enqueue\_many=False,\ shapes=None,\ name=None)}}
\item
  \protect\hyperlink{shuffleux5fbatch}{\texttt{tf.train.shuffle\_batch(tensor\_list,\ batch\_size,\ capacity,\ min\_after\_dequeue,\ num\_threads=1,\ seed=None,\ enqueue\_many=False,\ shapes=None,\ name=None)}}
\item
  \protect\hyperlink{shuffleux5fbatchux5fjoin}{\texttt{tf.train.shuffle\_batch\_join(tensor\_list\_list,\ batch\_size,\ capacity,\ min\_after\_dequeue,\ seed=None,\ enqueue\_many=False,\ shapes=None,\ name=None)}}
\end{itemize}

\subsection{Placeholders }\label{placeholders}

TensorFlow provides a placeholder operation that must be fed with data
on execution. For more info, see the section on
\href{../../how_tos/reading_data/index.md\#feeding}{Feeding data}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.placeholder(dtype,\ shape=None,\ name=None)}
}{tf.placeholder(dtype, shape=None, name=None) }}\label{tf.placeholderdtype-shapenone-namenone}

Inserts a placeholder for a tensor that will be always fed.

\textbf{Important}: This tensor will produce an error if evaluated. Its
value must be fed using the \texttt{feed\_dict} optional argument to
\texttt{Session.run()}, \texttt{Tensor.eval()}, or
\texttt{Operation.run()}.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \NormalTok{tf.placeholder(}\BuiltInTok{float}\NormalTok{, shape}\OperatorTok{=}\NormalTok{(}\DecValTok{1024}\NormalTok{, }\DecValTok{1024}\NormalTok{))}
\NormalTok{y }\OperatorTok{=} \NormalTok{tf.matmul(x, x)}

\ControlFlowTok{with} \NormalTok{tf.Session() }\ImportTok{as} \NormalTok{sess:}
  \BuiltInTok{print} \NormalTok{sess.run(y)  }\CommentTok{# ERROR: will fail because x was not fed.}

  \NormalTok{rand_array }\OperatorTok{=} \NormalTok{np.random.rand(}\DecValTok{1024}\NormalTok{, }\DecValTok{1024}\NormalTok{)}
  \BuiltInTok{print} \NormalTok{sess.run(y, feed_dict}\OperatorTok{=}\NormalTok{\{x: rand_array\})  }\CommentTok{# Will succeed.}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args}

\begin{itemize}
\tightlist
\item
  \texttt{dtype}: The type of elements in the tensor to be fed.
\item
  \texttt{shape}: The shape of the tensor to be fed (optional). If the
  shape is not specified, you can feed a tensor of any shape.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns}

A \texttt{Tensor} that may be used as a handle for feeding a value, but
not evaluated directly.

\subsection{Readers }\label{readers}

TensorFlow provides a set of Reader classes for reading data formats.
For more information on inputs and readers, see
\href{../../how_tos/reading_data/index.md}{Reading data}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.ReaderBase}
}{class tf.ReaderBase }}\label{class-tf.readerbase}

Base class for different Reader types, that produce a record every step.

Conceptually, Readers convert string `work units' into records (key,
value pairs). Typically the `work units' are filenames and the records
are extracted from the contents of those files. We want a single record
produced per step, but a work unit can correspond to many records.

Therefore we introduce some decoupling using a queue. The queue contains
the work units and the Reader dequeues from the queue when it is asked
to produce a record (via Read()) but it has finished the last work unit.
- - -

\paragraph{\texorpdfstring{\texttt{tf.ReaderBase.\_\_init\_\_(reader\_ref,\ supports\_serialize=False)}
}{tf.ReaderBase.\_\_init\_\_(reader\_ref, supports\_serialize=False) }}\label{tf.readerbase.ux5fux5finitux5fux5freaderux5fref-supportsux5fserializefalse}

Creates a new ReaderBase.

\subparagraph{Args: }\label{args-1}

\begin{itemize}
\tightlist
\item
  \texttt{reader\_ref}: The operation that implements the reader.
\item
  \texttt{supports\_serialize}: True if the reader implementation can
  serialize its state.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.ReaderBase.num\_records\_produced(name=None)}
}{tf.ReaderBase.num\_records\_produced(name=None) }}\label{tf.readerbase.numux5frecordsux5fproducednamenone}

Returns the number of records this reader has produced.

This is the same as the number of Read executions that have succeeded.

\subparagraph{Args: }\label{args-2}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-1}

An int64 Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.ReaderBase.num\_work\_units\_completed(name=None)}
}{tf.ReaderBase.num\_work\_units\_completed(name=None) }}\label{tf.readerbase.numux5fworkux5funitsux5fcompletednamenone}

Returns the number of work units this reader has finished processing.

\subparagraph{Args: }\label{args-3}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-2}

An int64 Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.ReaderBase.read(queue,\ name=None)}
}{tf.ReaderBase.read(queue, name=None) }}\label{tf.readerbase.readqueue-namenone}

Returns the next record (key, value pair) produced by a reader.

Will dequeue a work unit from queue if necessary (e.g.~when the Reader
needs to start reading from a new file since it has finished with the
previous file).

\subparagraph{Args: }\label{args-4}

\begin{itemize}
\tightlist
\item
  \texttt{queue}: A Queue or a mutable string Tensor representing a
  handle to a Queue, with string work items.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-3}

A tuple of Tensors (key, value).

\begin{itemize}
\tightlist
\item
  \texttt{key}: A string scalar Tensor.
\item
  \texttt{value}: A string scalar Tensor.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.ReaderBase.reader\_ref}
}{tf.ReaderBase.reader\_ref }}\label{tf.readerbase.readerux5fref}

Op that implements the reader.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.ReaderBase.reset(name=None)}
}{tf.ReaderBase.reset(name=None) }}\label{tf.readerbase.resetnamenone}

Restore a reader to its initial clean state.

\subparagraph{Args: }\label{args-5}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-4}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.ReaderBase.restore\_state(state,\ name=None)}
}{tf.ReaderBase.restore\_state(state, name=None) }}\label{tf.readerbase.restoreux5fstatestate-namenone}

Restore a reader to a previously saved state.

Not all Readers support being restored, so this can produce an
Unimplemented error.

\subparagraph{Args: }\label{args-6}

\begin{itemize}
\tightlist
\item
  \texttt{state}: A string Tensor. Result of a SerializeState of a
  Reader with matching type.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-5}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.ReaderBase.serialize\_state(name=None)}
}{tf.ReaderBase.serialize\_state(name=None) }}\label{tf.readerbase.serializeux5fstatenamenone}

Produce a string tensor that encodes the state of a reader.

Not all Readers support being serialized, so this can produce an
Unimplemented error.

\subparagraph{Args: }\label{args-7}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-6}

A string Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.ReaderBase.supports\_serialize}
}{tf.ReaderBase.supports\_serialize }}\label{tf.readerbase.supportsux5fserialize}

Whether the Reader implementation can serialize its state.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.TextLineReader}
}{class tf.TextLineReader }}\label{class-tf.textlinereader}

A Reader that outputs the lines of a file delimited by newlines.

Newlines are stripped from the output. See ReaderBase for supported
methods. - - -

\paragraph{\texorpdfstring{\texttt{tf.TextLineReader.\_\_init\_\_(skip\_header\_lines=None,\ name=None)}
}{tf.TextLineReader.\_\_init\_\_(skip\_header\_lines=None, name=None) }}\label{tf.textlinereader.ux5fux5finitux5fux5fskipux5fheaderux5flinesnone-namenone}

Create a TextLineReader.

\subparagraph{Args: }\label{args-8}

\begin{itemize}
\tightlist
\item
  \texttt{skip\_header\_lines}: An optional int. Defaults to 0. Number
  of lines to skip from the beginning of every file.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TextLineReader.num\_records\_produced(name=None)}
}{tf.TextLineReader.num\_records\_produced(name=None) }}\label{tf.textlinereader.numux5frecordsux5fproducednamenone}

Returns the number of records this reader has produced.

This is the same as the number of Read executions that have succeeded.

\subparagraph{Args: }\label{args-9}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-7}

An int64 Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TextLineReader.num\_work\_units\_completed(name=None)}
}{tf.TextLineReader.num\_work\_units\_completed(name=None) }}\label{tf.textlinereader.numux5fworkux5funitsux5fcompletednamenone}

Returns the number of work units this reader has finished processing.

\subparagraph{Args: }\label{args-10}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-8}

An int64 Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TextLineReader.read(queue,\ name=None)}
}{tf.TextLineReader.read(queue, name=None) }}\label{tf.textlinereader.readqueue-namenone}

Returns the next record (key, value pair) produced by a reader.

Will dequeue a work unit from queue if necessary (e.g.~when the Reader
needs to start reading from a new file since it has finished with the
previous file).

\subparagraph{Args: }\label{args-11}

\begin{itemize}
\tightlist
\item
  \texttt{queue}: A Queue or a mutable string Tensor representing a
  handle to a Queue, with string work items.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-9}

A tuple of Tensors (key, value).

\begin{itemize}
\tightlist
\item
  \texttt{key}: A string scalar Tensor.
\item
  \texttt{value}: A string scalar Tensor.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TextLineReader.reader\_ref}
}{tf.TextLineReader.reader\_ref }}\label{tf.textlinereader.readerux5fref}

Op that implements the reader.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TextLineReader.reset(name=None)}
}{tf.TextLineReader.reset(name=None) }}\label{tf.textlinereader.resetnamenone}

Restore a reader to its initial clean state.

\subparagraph{Args: }\label{args-12}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-10}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TextLineReader.restore\_state(state,\ name=None)}
}{tf.TextLineReader.restore\_state(state, name=None) }}\label{tf.textlinereader.restoreux5fstatestate-namenone}

Restore a reader to a previously saved state.

Not all Readers support being restored, so this can produce an
Unimplemented error.

\subparagraph{Args: }\label{args-13}

\begin{itemize}
\tightlist
\item
  \texttt{state}: A string Tensor. Result of a SerializeState of a
  Reader with matching type.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-11}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TextLineReader.serialize\_state(name=None)}
}{tf.TextLineReader.serialize\_state(name=None) }}\label{tf.textlinereader.serializeux5fstatenamenone}

Produce a string tensor that encodes the state of a reader.

Not all Readers support being serialized, so this can produce an
Unimplemented error.

\subparagraph{Args: }\label{args-14}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-12}

A string Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TextLineReader.supports\_serialize}
}{tf.TextLineReader.supports\_serialize }}\label{tf.textlinereader.supportsux5fserialize}

Whether the Reader implementation can serialize its state.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.WholeFileReader}
}{class tf.WholeFileReader }}\label{class-tf.wholefilereader}

A Reader that outputs the entire contents of a file as a value.

To use, enqueue filenames in a Queue. The output of Read will be a
filename (key) and the contents of that file (value).

See ReaderBase for supported methods. - - -

\paragraph{\texorpdfstring{\texttt{tf.WholeFileReader.\_\_init\_\_(name=None)}
}{tf.WholeFileReader.\_\_init\_\_(name=None) }}\label{tf.wholefilereader.ux5fux5finitux5fux5fnamenone}

Create a WholeFileReader.

\subparagraph{Args: }\label{args-15}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.WholeFileReader.num\_records\_produced(name=None)}
}{tf.WholeFileReader.num\_records\_produced(name=None) }}\label{tf.wholefilereader.numux5frecordsux5fproducednamenone}

Returns the number of records this reader has produced.

This is the same as the number of Read executions that have succeeded.

\subparagraph{Args: }\label{args-16}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-13}

An int64 Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.WholeFileReader.num\_work\_units\_completed(name=None)}
}{tf.WholeFileReader.num\_work\_units\_completed(name=None) }}\label{tf.wholefilereader.numux5fworkux5funitsux5fcompletednamenone}

Returns the number of work units this reader has finished processing.

\subparagraph{Args: }\label{args-17}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-14}

An int64 Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.WholeFileReader.read(queue,\ name=None)}
}{tf.WholeFileReader.read(queue, name=None) }}\label{tf.wholefilereader.readqueue-namenone}

Returns the next record (key, value pair) produced by a reader.

Will dequeue a work unit from queue if necessary (e.g.~when the Reader
needs to start reading from a new file since it has finished with the
previous file).

\subparagraph{Args: }\label{args-18}

\begin{itemize}
\tightlist
\item
  \texttt{queue}: A Queue or a mutable string Tensor representing a
  handle to a Queue, with string work items.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-15}

A tuple of Tensors (key, value).

\begin{itemize}
\tightlist
\item
  \texttt{key}: A string scalar Tensor.
\item
  \texttt{value}: A string scalar Tensor.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.WholeFileReader.reader\_ref}
}{tf.WholeFileReader.reader\_ref }}\label{tf.wholefilereader.readerux5fref}

Op that implements the reader.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.WholeFileReader.reset(name=None)}
}{tf.WholeFileReader.reset(name=None) }}\label{tf.wholefilereader.resetnamenone}

Restore a reader to its initial clean state.

\subparagraph{Args: }\label{args-19}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-16}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.WholeFileReader.restore\_state(state,\ name=None)}
}{tf.WholeFileReader.restore\_state(state, name=None) }}\label{tf.wholefilereader.restoreux5fstatestate-namenone}

Restore a reader to a previously saved state.

Not all Readers support being restored, so this can produce an
Unimplemented error.

\subparagraph{Args: }\label{args-20}

\begin{itemize}
\tightlist
\item
  \texttt{state}: A string Tensor. Result of a SerializeState of a
  Reader with matching type.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-17}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.WholeFileReader.serialize\_state(name=None)}
}{tf.WholeFileReader.serialize\_state(name=None) }}\label{tf.wholefilereader.serializeux5fstatenamenone}

Produce a string tensor that encodes the state of a reader.

Not all Readers support being serialized, so this can produce an
Unimplemented error.

\subparagraph{Args: }\label{args-21}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-18}

A string Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.WholeFileReader.supports\_serialize}
}{tf.WholeFileReader.supports\_serialize }}\label{tf.wholefilereader.supportsux5fserialize}

Whether the Reader implementation can serialize its state.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.IdentityReader}
}{class tf.IdentityReader }}\label{class-tf.identityreader}

A Reader that outputs the queued work as both the key and value.

To use, enqueue strings in a Queue. Read will take the front work string
and output (work, work).

See ReaderBase for supported methods. - - -

\paragraph{\texorpdfstring{\texttt{tf.IdentityReader.\_\_init\_\_(name=None)}
}{tf.IdentityReader.\_\_init\_\_(name=None) }}\label{tf.identityreader.ux5fux5finitux5fux5fnamenone}

Create a IdentityReader.

\subparagraph{Args: }\label{args-22}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.IdentityReader.num\_records\_produced(name=None)}
}{tf.IdentityReader.num\_records\_produced(name=None) }}\label{tf.identityreader.numux5frecordsux5fproducednamenone}

Returns the number of records this reader has produced.

This is the same as the number of Read executions that have succeeded.

\subparagraph{Args: }\label{args-23}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-19}

An int64 Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.IdentityReader.num\_work\_units\_completed(name=None)}
}{tf.IdentityReader.num\_work\_units\_completed(name=None) }}\label{tf.identityreader.numux5fworkux5funitsux5fcompletednamenone}

Returns the number of work units this reader has finished processing.

\subparagraph{Args: }\label{args-24}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-20}

An int64 Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.IdentityReader.read(queue,\ name=None)}
}{tf.IdentityReader.read(queue, name=None) }}\label{tf.identityreader.readqueue-namenone}

Returns the next record (key, value pair) produced by a reader.

Will dequeue a work unit from queue if necessary (e.g.~when the Reader
needs to start reading from a new file since it has finished with the
previous file).

\subparagraph{Args: }\label{args-25}

\begin{itemize}
\tightlist
\item
  \texttt{queue}: A Queue or a mutable string Tensor representing a
  handle to a Queue, with string work items.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-21}

A tuple of Tensors (key, value).

\begin{itemize}
\tightlist
\item
  \texttt{key}: A string scalar Tensor.
\item
  \texttt{value}: A string scalar Tensor.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.IdentityReader.reader\_ref}
}{tf.IdentityReader.reader\_ref }}\label{tf.identityreader.readerux5fref}

Op that implements the reader.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.IdentityReader.reset(name=None)}
}{tf.IdentityReader.reset(name=None) }}\label{tf.identityreader.resetnamenone}

Restore a reader to its initial clean state.

\subparagraph{Args: }\label{args-26}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-22}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.IdentityReader.restore\_state(state,\ name=None)}
}{tf.IdentityReader.restore\_state(state, name=None) }}\label{tf.identityreader.restoreux5fstatestate-namenone}

Restore a reader to a previously saved state.

Not all Readers support being restored, so this can produce an
Unimplemented error.

\subparagraph{Args: }\label{args-27}

\begin{itemize}
\tightlist
\item
  \texttt{state}: A string Tensor. Result of a SerializeState of a
  Reader with matching type.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-23}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.IdentityReader.serialize\_state(name=None)}
}{tf.IdentityReader.serialize\_state(name=None) }}\label{tf.identityreader.serializeux5fstatenamenone}

Produce a string tensor that encodes the state of a reader.

Not all Readers support being serialized, so this can produce an
Unimplemented error.

\subparagraph{Args: }\label{args-28}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-24}

A string Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.IdentityReader.supports\_serialize}
}{tf.IdentityReader.supports\_serialize }}\label{tf.identityreader.supportsux5fserialize}

Whether the Reader implementation can serialize its state.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.TFRecordReader}
}{class tf.TFRecordReader }}\label{class-tf.tfrecordreader}

A Reader that outputs the records from a TFRecords file.

See ReaderBase for supported methods. - - -

\paragraph{\texorpdfstring{\texttt{tf.TFRecordReader.\_\_init\_\_(name=None)}
}{tf.TFRecordReader.\_\_init\_\_(name=None) }}\label{tf.tfrecordreader.ux5fux5finitux5fux5fnamenone}

Create a TFRecordReader.

\subparagraph{Args: }\label{args-29}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TFRecordReader.num\_records\_produced(name=None)}
}{tf.TFRecordReader.num\_records\_produced(name=None) }}\label{tf.tfrecordreader.numux5frecordsux5fproducednamenone}

Returns the number of records this reader has produced.

This is the same as the number of Read executions that have succeeded.

\subparagraph{Args: }\label{args-30}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-25}

An int64 Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TFRecordReader.num\_work\_units\_completed(name=None)}
}{tf.TFRecordReader.num\_work\_units\_completed(name=None) }}\label{tf.tfrecordreader.numux5fworkux5funitsux5fcompletednamenone}

Returns the number of work units this reader has finished processing.

\subparagraph{Args: }\label{args-31}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-26}

An int64 Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TFRecordReader.read(queue,\ name=None)}
}{tf.TFRecordReader.read(queue, name=None) }}\label{tf.tfrecordreader.readqueue-namenone}

Returns the next record (key, value pair) produced by a reader.

Will dequeue a work unit from queue if necessary (e.g.~when the Reader
needs to start reading from a new file since it has finished with the
previous file).

\subparagraph{Args: }\label{args-32}

\begin{itemize}
\tightlist
\item
  \texttt{queue}: A Queue or a mutable string Tensor representing a
  handle to a Queue, with string work items.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-27}

A tuple of Tensors (key, value).

\begin{itemize}
\tightlist
\item
  \texttt{key}: A string scalar Tensor.
\item
  \texttt{value}: A string scalar Tensor.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TFRecordReader.reader\_ref}
}{tf.TFRecordReader.reader\_ref }}\label{tf.tfrecordreader.readerux5fref}

Op that implements the reader.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TFRecordReader.reset(name=None)}
}{tf.TFRecordReader.reset(name=None) }}\label{tf.tfrecordreader.resetnamenone}

Restore a reader to its initial clean state.

\subparagraph{Args: }\label{args-33}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-28}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TFRecordReader.restore\_state(state,\ name=None)}
}{tf.TFRecordReader.restore\_state(state, name=None) }}\label{tf.tfrecordreader.restoreux5fstatestate-namenone}

Restore a reader to a previously saved state.

Not all Readers support being restored, so this can produce an
Unimplemented error.

\subparagraph{Args: }\label{args-34}

\begin{itemize}
\tightlist
\item
  \texttt{state}: A string Tensor. Result of a SerializeState of a
  Reader with matching type.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-29}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TFRecordReader.serialize\_state(name=None)}
}{tf.TFRecordReader.serialize\_state(name=None) }}\label{tf.tfrecordreader.serializeux5fstatenamenone}

Produce a string tensor that encodes the state of a reader.

Not all Readers support being serialized, so this can produce an
Unimplemented error.

\subparagraph{Args: }\label{args-35}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-30}

A string Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.TFRecordReader.supports\_serialize}
}{tf.TFRecordReader.supports\_serialize }}\label{tf.tfrecordreader.supportsux5fserialize}

Whether the Reader implementation can serialize its state.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.FixedLengthRecordReader}
}{class tf.FixedLengthRecordReader }}\label{class-tf.fixedlengthrecordreader}

A Reader that outputs fixed-length records from a file.

See ReaderBase for supported methods. - - -

\paragraph{\texorpdfstring{\texttt{tf.FixedLengthRecordReader.\_\_init\_\_(record\_bytes,\ header\_bytes=None,\ footer\_bytes=None,\ name=None)}
}{tf.FixedLengthRecordReader.\_\_init\_\_(record\_bytes, header\_bytes=None, footer\_bytes=None, name=None) }}\label{tf.fixedlengthrecordreader.ux5fux5finitux5fux5frecordux5fbytes-headerux5fbytesnone-footerux5fbytesnone-namenone}

Create a FixedLengthRecordReader.

\subparagraph{Args: }\label{args-36}

\begin{itemize}
\tightlist
\item
  \texttt{record\_bytes}: An int.
\item
  \texttt{header\_bytes}: An optional int. Defaults to 0.
\item
  \texttt{footer\_bytes}: An optional int. Defaults to 0.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.FixedLengthRecordReader.num\_records\_produced(name=None)}
}{tf.FixedLengthRecordReader.num\_records\_produced(name=None) }}\label{tf.fixedlengthrecordreader.numux5frecordsux5fproducednamenone}

Returns the number of records this reader has produced.

This is the same as the number of Read executions that have succeeded.

\subparagraph{Args: }\label{args-37}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-31}

An int64 Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.FixedLengthRecordReader.num\_work\_units\_completed(name=None)}
}{tf.FixedLengthRecordReader.num\_work\_units\_completed(name=None) }}\label{tf.fixedlengthrecordreader.numux5fworkux5funitsux5fcompletednamenone}

Returns the number of work units this reader has finished processing.

\subparagraph{Args: }\label{args-38}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-32}

An int64 Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.FixedLengthRecordReader.read(queue,\ name=None)}
}{tf.FixedLengthRecordReader.read(queue, name=None) }}\label{tf.fixedlengthrecordreader.readqueue-namenone}

Returns the next record (key, value pair) produced by a reader.

Will dequeue a work unit from queue if necessary (e.g.~when the Reader
needs to start reading from a new file since it has finished with the
previous file).

\subparagraph{Args: }\label{args-39}

\begin{itemize}
\tightlist
\item
  \texttt{queue}: A Queue or a mutable string Tensor representing a
  handle to a Queue, with string work items.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-33}

A tuple of Tensors (key, value).

\begin{itemize}
\tightlist
\item
  \texttt{key}: A string scalar Tensor.
\item
  \texttt{value}: A string scalar Tensor.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.FixedLengthRecordReader.reader\_ref}
}{tf.FixedLengthRecordReader.reader\_ref }}\label{tf.fixedlengthrecordreader.readerux5fref}

Op that implements the reader.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.FixedLengthRecordReader.reset(name=None)}
}{tf.FixedLengthRecordReader.reset(name=None) }}\label{tf.fixedlengthrecordreader.resetnamenone}

Restore a reader to its initial clean state.

\subparagraph{Args: }\label{args-40}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-34}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.FixedLengthRecordReader.restore\_state(state,\ name=None)}
}{tf.FixedLengthRecordReader.restore\_state(state, name=None) }}\label{tf.fixedlengthrecordreader.restoreux5fstatestate-namenone}

Restore a reader to a previously saved state.

Not all Readers support being restored, so this can produce an
Unimplemented error.

\subparagraph{Args: }\label{args-41}

\begin{itemize}
\tightlist
\item
  \texttt{state}: A string Tensor. Result of a SerializeState of a
  Reader with matching type.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-35}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.FixedLengthRecordReader.serialize\_state(name=None)}
}{tf.FixedLengthRecordReader.serialize\_state(name=None) }}\label{tf.fixedlengthrecordreader.serializeux5fstatenamenone}

Produce a string tensor that encodes the state of a reader.

Not all Readers support being serialized, so this can produce an
Unimplemented error.

\subparagraph{Args: }\label{args-42}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-36}

A string Tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.FixedLengthRecordReader.supports\_serialize}
}{tf.FixedLengthRecordReader.supports\_serialize }}\label{tf.fixedlengthrecordreader.supportsux5fserialize}

Whether the Reader implementation can serialize its state.

\subsection{Converting }\label{converting}

TensorFlow provides several operations that you can use to convert
various data formats into tensors.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.decode\_csv(records,\ record\_defaults,\ field\_delim=None,\ name=None)}
}{tf.decode\_csv(records, record\_defaults, field\_delim=None, name=None) }}\label{tf.decodeux5fcsvrecords-recordux5fdefaults-fieldux5fdelimnone-namenone}

Convert CSV records to tensors. Each column maps to one tensor.

RFC 4180 format is expected for the CSV records.
(https://tools.ietf.org/html/rfc4180) Note that we allow leading and
trailing spaces with int or float field.

\subparagraph{Args: }\label{args-43}

\begin{itemize}
\tightlist
\item
  \texttt{records}: A \texttt{Tensor} of type \texttt{string}. Each
  string is a record/row in the csv and all records should have the same
  format.
\item
  \texttt{record\_defaults}: A list of \texttt{Tensor} objects with
  types from: \texttt{float32}, \texttt{int32}, \texttt{int64},
  \texttt{string}. One tensor per column of the input record, with
  either a scalar default value for that column or empty if the column
  is required.
\item
  \texttt{field\_delim}: An optional \texttt{string}. Defaults to
  \texttt{","}. delimiter to separate fields in a record.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-37}

A list of \texttt{Tensor} objects. Has the same type as
\texttt{record\_defaults}. Each tensor will have the same shape as
records.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.decode\_raw(bytes,\ out\_type,\ little\_endian=None,\ name=None)}
}{tf.decode\_raw(bytes, out\_type, little\_endian=None, name=None) }}\label{tf.decodeux5frawbytes-outux5ftype-littleux5fendiannone-namenone}

Reinterpret the bytes of a string as a vector of numbers.

\subparagraph{Args: }\label{args-44}

\begin{itemize}
\tightlist
\item
  \texttt{bytes}: A \texttt{Tensor} of type \texttt{string}. All the
  elements must have the same length.
\item
  \texttt{out\_type}: A \texttt{tf.DType} from:
  \texttt{tf.float32,\ tf.float64,\ tf.int32,\ tf.uint8,\ tf.int16,\ tf.int8,\ tf.int64}.
\item
  \texttt{little\_endian}: An optional \texttt{bool}. Defaults to
  \texttt{True}. Whether the input bytes are in little-endian order.
  Ignored for out\_types that are stored in a single byte like uint8.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-38}

A \texttt{Tensor} of type \texttt{out\_type}. A Tensor with one more
dimension than the input bytes. The added dimension will have size equal
to the length of the elements of bytes divided by the number of bytes to
represent out\_type.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{Example protocol buffer }\label{example-protocol-buffer}

TensorFlow's
\href{../../how_tos/reading_data/index.md\#standard-tensorflow-format}{recommended
format for training examples} is serialized \texttt{Example} protocol
buffers,
\href{https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/example/example.proto}{described
here}. They contain \texttt{Features},
\href{https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/example/feature.proto}{described
here}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.parse\_example(serialized,\ names=None,\ sparse\_keys=None,\ sparse\_types=None,\ dense\_keys=None,\ dense\_types=None,\ dense\_defaults=None,\ dense\_shapes=None,\ name=\textquotesingle{}ParseExample\textquotesingle{})}
}{tf.parse\_example(serialized, names=None, sparse\_keys=None, sparse\_types=None, dense\_keys=None, dense\_types=None, dense\_defaults=None, dense\_shapes=None, name='ParseExample') }}\label{tf.parseux5fexampleserialized-namesnone-sparseux5fkeysnone-sparseux5ftypesnone-denseux5fkeysnone-denseux5ftypesnone-denseux5fdefaultsnone-denseux5fshapesnone-nameparseexample}

Parses \texttt{Example} protos.

Parses a number of serialized {[}\texttt{Example}{]}
(https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/example/example.proto)
protos given in \texttt{serialized}.

\texttt{names} may contain descriptive names for the corresponding
serialized protos. These may be useful for debugging purposes, but they
have no effect on the output. If not \texttt{None}, \texttt{names} must
be the same length as \texttt{serialized}.

This op parses serialized examples into a dictionary mapping keys to
\texttt{Tensor} and \texttt{SparseTensor} objects respectively,
depending on whether the keys appear in \texttt{sparse\_keys} or
\texttt{dense\_keys}.

The key \texttt{dense\_keys{[}j{]}} is mapped to a \texttt{Tensor} of
type \texttt{dense\_types{[}j{]}} and of shape
\texttt{(serialized.size(),)\ +\ dense\_shapes{[}j{]}}.

\texttt{dense\_defaults} provides defaults for values referenced using
\texttt{dense\_keys}. If a key is not present in this dictionary, the
corresponding dense \texttt{Feature} is required in all elements of
\texttt{serialized}.

\texttt{dense\_shapes{[}j{]}} provides the shape of each
\texttt{Feature} entry referenced by \texttt{dense\_keys{[}j{]}}. The
number of elements in the \texttt{Feature} corresponding to
\texttt{dense\_key{[}j{]}} must always have
\texttt{np.prod(dense\_shapes{[}j{]})} entries. The returned
\texttt{Tensor} for \texttt{dense\_key{[}j{]}} has shape
\texttt{{[}N{]}\ +\ dense\_shape{[}j{]}}, where \texttt{N} is the number
of \texttt{Example}s in \texttt{serialized}.

The key \texttt{sparse\_keys{[}j{]}} is mapped to a
\texttt{SparseTensor} of type \texttt{sparse\_types{[}j{]}}. The
\texttt{SparseTensor} represents a ragged matrix. Its indices are
\texttt{{[}batch,\ index{]}} where \texttt{batch} is the batch entry the
value is from, and \texttt{index} is the value's index in the list of
values associated with that feature and example.

Examples:

For example, if one expects a \texttt{tf.float32} sparse feature
\texttt{ft} and three serialized \texttt{Example}s are provided:

\begin{verbatim}
serialized = [
  features:
    { feature: [ key: { "ft" value: float_list: { value: [1.0, 2.0] } } ] },
  features:
    { feature: [] },
  features:
    { feature: [ key: { "ft" value: float_list: { value: [3.0] } } ] }
]
\end{verbatim}

then the output will look like:

\begin{verbatim}
{"ft": SparseTensor(indices=[[0, 0], [0, 1], [2, 0]],
                    values=[1.0, 2.0, 3.0],
                    shape=(3, 2)) }
\end{verbatim}

Given two \texttt{Example} input protos in \texttt{serialized}:

\begin{verbatim}
[
  features: {
    feature: { key: "kw" value: { bytes_list: { value: [ "knit", "big" ] } } }
    feature: { key: "gps" value: { float_list: { value: [] } } }
  },
  features: {
    feature: { key: "kw" value: { bytes_list: { value: [ "emmy" ] } } }
    feature: { key: "dank" value: { int64_list: { value: [ 42 ] } } }
    feature: { key: "gps" value: { } }
  }
]
\end{verbatim}

And arguments

\begin{verbatim}
  names: ["input0", "input1"],
  sparse_keys: ["kw", "dank", "gps"]
  sparse_types: [DT_STRING, DT_INT64, DT_FLOAT]
\end{verbatim}

Then the output is a dictionary:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{}
  \StringTok{"kw"}\NormalTok{: SparseTensor(}
      \NormalTok{indices}\OperatorTok{=}\NormalTok{[[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{], [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{], [}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{]],}
      \NormalTok{values}\OperatorTok{=}\NormalTok{[}\StringTok{"knit"}\NormalTok{, }\StringTok{"big"}\NormalTok{, }\StringTok{"emmy"}\NormalTok{]}
      \NormalTok{shape}\OperatorTok{=}\NormalTok{[}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{]),}
  \CommentTok{"dank"}\NormalTok{: SparseTensor(}
      \NormalTok{indices}\OperatorTok{=}\NormalTok{[[}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{]],}
      \NormalTok{values}\OperatorTok{=}\NormalTok{[}\DecValTok{42}\NormalTok{],}
      \NormalTok{shape}\OperatorTok{=}\NormalTok{[}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{]),}
  \CommentTok{"gps"}\NormalTok{: SparseTensor(}
      \NormalTok{indices}\OperatorTok{=}\NormalTok{[],}
      \NormalTok{values}\OperatorTok{=}\NormalTok{[],}
      \NormalTok{shape}\OperatorTok{=}\NormalTok{[}\DecValTok{2}\NormalTok{, }\DecValTok{0}\NormalTok{]),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

For dense results in two serialized \texttt{Example}s:

\begin{verbatim}
[
  features: {
    feature: { key: "age" value: { int64_list: { value: [ 0 ] } } }
    feature: { key: "gender" value: { bytes_list: { value: [ "f" ] } } }
   },
   features: {
    feature: { key: "age" value: { int64_list: { value: [] } } }
    feature: { key: "gender" value: { bytes_list: { value: [ "f" ] } } }
  }
]
\end{verbatim}

We can use arguments:

\begin{verbatim}
names: ["input0", "input1"],
dense_keys: np.array(["age", "gender"]),
dense_types: [tf.int64, tf.string],
dense_defaults: {
  "age": -1  # "age" defaults to -1 if missing
             # "gender" has no specified default so it's required
}
dense_shapes: [(1,), (1,)],  # age, gender, label, weight
\end{verbatim}

And the expected output is:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{}
  \StringTok{"age"}\NormalTok{: [[}\DecValTok{0}\NormalTok{], [}\OperatorTok{-}\DecValTok{1}\NormalTok{]],}
  \CommentTok{"gender"}\NormalTok{: [[}\StringTok{"f"}\NormalTok{], [}\StringTok{"f"}\NormalTok{]],}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-45}

\begin{itemize}
\tightlist
\item
  \texttt{serialized}: A list of strings, a batch of binary serialized
  \texttt{Example} protos.
\item
  \texttt{names}: A list of strings, the names of the serialized protos.
\item
  \texttt{sparse\_keys}: A list of string keys in the examples'
  features. The results for these keys will be returned as
  \texttt{SparseTensor} objects.
\item
  \texttt{sparse\_types}: A list of \texttt{DTypes} of the same length
  as \texttt{sparse\_keys}. Only \texttt{tf.float32}
  (\texttt{FloatList}), \texttt{tf.int64} (\texttt{Int64List}), and
  \texttt{tf.string} (\texttt{BytesList}) are supported.
\item
  \texttt{dense\_keys}: A list of string keys in the examples' features.
  The results for these keys will be returned as \texttt{Tensor}s
\item
  \texttt{dense\_types}: A list of DTypes of the same length as
  \texttt{dense\_keys}. Only \texttt{tf.float32} (\texttt{FloatList}),
  \texttt{tf.int64} (\texttt{Int64List}), and \texttt{tf.string}
  (\texttt{BytesList}) are supported.
\item
  \texttt{dense\_defaults}: A dict mapping string keys to
  \texttt{Tensor}s. The keys of the dict must match the dense\_keys of
  the feature.
\item
  \texttt{dense\_shapes}: A list of tuples with the same length as
  \texttt{dense\_keys}. The shape of the data for each dense feature
  referenced by \texttt{dense\_keys}.
\item
  \texttt{name}: A name for this operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-39}

A \texttt{dict} mapping keys to \texttt{Tensor}s and
\texttt{SparseTensor}s.

\subparagraph{Raises: }\label{raises}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: If sparse and dense key sets intersect, or input
  lengths do not match up.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.parse\_single\_example(serialized,\ names=None,\ sparse\_keys=None,\ sparse\_types=None,\ dense\_keys=None,\ dense\_types=None,\ dense\_defaults=None,\ dense\_shapes=None,\ name=\textquotesingle{}ParseSingleExample\textquotesingle{})}
}{tf.parse\_single\_example(serialized, names=None, sparse\_keys=None, sparse\_types=None, dense\_keys=None, dense\_types=None, dense\_defaults=None, dense\_shapes=None, name='ParseSingleExample') }}\label{tf.parseux5fsingleux5fexampleserialized-namesnone-sparseux5fkeysnone-sparseux5ftypesnone-denseux5fkeysnone-denseux5ftypesnone-denseux5fdefaultsnone-denseux5fshapesnone-nameparsesingleexample}

Parses a single \texttt{Example} proto.

Similar to \texttt{parse\_example}, except:

For dense tensors, the returned \texttt{Tensor} is identical to the
output of \texttt{parse\_example}, except there is no batch dimension,
the output shape is the same as the shape given in
\texttt{dense\_shape}.

For \texttt{SparseTensor}s, the first (batch) column of the indices
matrix is removed (the indices matrix is a column vector), the values
vector is unchanged, and the first (batch\_size) entry of the shape
vector is removed (it is now a single element vector).

See also \texttt{parse\_example}.

\subparagraph{Args: }\label{args-46}

\begin{itemize}
\tightlist
\item
  \texttt{serialized}: A scalar string, a single serialized Example. See
  parse\_example documentation for more details.
\item
  \texttt{names}: (Optional) A scalar string, the associated name. See
  parse\_example documentation for more details.
\item
  \texttt{sparse\_keys}: See parse\_example documentation for more
  details.
\item
  \texttt{sparse\_types}: See parse\_example documentation for more
  details.
\item
  \texttt{dense\_keys}: See parse\_example documentation for more
  details.
\item
  \texttt{dense\_types}: See parse\_example documentation for more
  details.
\item
  \texttt{dense\_defaults}: See parse\_example documentation for more
  details.
\item
  \texttt{dense\_shapes}: See parse\_example documentation for more
  details.
\item
  \texttt{name}: A name for this operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-40}

A dictionary mapping keys to Tensors and SparseTensors.

\subparagraph{Raises: }\label{raises-1}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if ``scalar'' or ``names'' have known shapes, and
  are not scalars.
\end{itemize}

\subsection{Queues }\label{queues}

TensorFlow provides several implementations of `Queues', which are
structures within the TensorFlow computation graph to stage pipelines of
tensors together. The following describe the basic Queue interface and
some implementations. To see an example use, see
\href{../../how_tos/threading_and_queues/index.md}{Threading and
Queues}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.QueueBase}
}{class tf.QueueBase }}\label{class-tf.queuebase}

Base class for queue implementations.

A queue is a TensorFlow data structure that stores tensors across
multiple steps, and exposes operations that enqueue and dequeue tensors.

Each queue element is a tuple of one or more tensors, where each tuple
component has a static dtype, and may have a static shape. The queue
implementations support versions of enqueue and dequeue that handle
single elements, versions that support enqueuing and dequeuing a batch
of elements at once.

See \protect\hyperlink{FIFOQueue}{\texttt{tf.FIFOQueue}} and
\protect\hyperlink{RandomShuffleQueue}{\texttt{tf.RandomShuffleQueue}}
for concrete implementations of this class, and instructions on how to
create them.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.QueueBase.enqueue(vals,\ name=None)}
}{tf.QueueBase.enqueue(vals, name=None) }}\label{tf.queuebase.enqueuevals-namenone}

Enqueues one element to this queue.

If the queue is full when this operation executes, it will block until
the element has been enqueued.

\subparagraph{Args: }\label{args-47}

\begin{itemize}
\tightlist
\item
  \texttt{vals}: The tuple of \texttt{Tensor} objects to be enqueued.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-41}

The operation that enqueues a new tuple of tensors to the queue.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.QueueBase.enqueue\_many(vals,\ name=None)}
}{tf.QueueBase.enqueue\_many(vals, name=None) }}\label{tf.queuebase.enqueueux5fmanyvals-namenone}

Enqueues zero or elements to this queue.

This operation slices each component tensor along the 0th dimension to
make multiple queue elements. All of the tensors in \texttt{vals} must
have the same size in the 0th dimension.

If the queue is full when this operation executes, it will block until
all of the elements have been enqueued.

\subparagraph{Args: }\label{args-48}

\begin{itemize}
\tightlist
\item
  \texttt{vals}: The tensor or tuple of tensors from which the queue
  elements are taken.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-42}

The operation that enqueues a batch of tuples of tensors to the queue.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.QueueBase.dequeue(name=None)}
}{tf.QueueBase.dequeue(name=None) }}\label{tf.queuebase.dequeuenamenone}

Dequeues one element from this queue.

If the queue is empty when this operation executes, it will block until
there is an element to dequeue.

\subparagraph{Args: }\label{args-49}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-43}

The tuple of tensors that was dequeued.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.QueueBase.dequeue\_many(n,\ name=None)}
}{tf.QueueBase.dequeue\_many(n, name=None) }}\label{tf.queuebase.dequeueux5fmanyn-namenone}

Dequeues and concatenates \texttt{n} elements from this queue.

This operation concatenates queue-element component tensors along the
0th dimension to make a single component tensor. All of the components
in the dequeued tuple will have size \texttt{n} in the 0th dimension.

If the queue contains fewer than \texttt{n} elements when this operation
executes, it will block until \texttt{n} elements have been dequeued.

\subparagraph{Args: }\label{args-50}

\begin{itemize}
\tightlist
\item
  \texttt{n}: A scalar \texttt{Tensor} containing the number of elements
  to dequeue.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-44}

The tuple of concatenated tensors that was dequeued.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.QueueBase.size(name=None)}
}{tf.QueueBase.size(name=None) }}\label{tf.queuebase.sizenamenone}

Compute the number of elements in this queue.

\subparagraph{Args: }\label{args-51}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-45}

A scalar tensor containing the number of elements in this queue.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.QueueBase.close(cancel\_pending\_enqueues=False,\ name=None)}
}{tf.QueueBase.close(cancel\_pending\_enqueues=False, name=None) }}\label{tf.queuebase.closecancelux5fpendingux5fenqueuesfalse-namenone}

Closes this queue.

This operation signals that no more elements will be enqueued in the
given queue. Subsequent \texttt{enqueue} and \texttt{enqueue\_many}
operations will fail. Subsequent \texttt{dequeue} and
\texttt{dequeue\_many} operations will continue to succeed if sufficient
elements remain in the queue. Subsequent \texttt{dequeue} and
\texttt{dequeue\_many} operations that would block will fail
immediately.

If \texttt{cancel\_pending\_enqueues} is \texttt{True}, all pending
requests will also be cancelled.

\subparagraph{Args: }\label{args-52}

\begin{itemize}
\tightlist
\item
  \texttt{cancel\_pending\_enqueues}: (Optional.) A boolean, defaulting
  to \texttt{False} (described above).
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-46}

The operation that closes the queue.

\paragraph{Other Methods }\label{other-methods}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.QueueBase.\_\_init\_\_(dtypes,\ shapes,\ queue\_ref)}
}{tf.QueueBase.\_\_init\_\_(dtypes, shapes, queue\_ref) }}\label{tf.queuebase.ux5fux5finitux5fux5fdtypes-shapes-queueux5fref}

Constructs a queue object from a queue reference.

\subparagraph{Args: }\label{args-53}

\begin{itemize}
\tightlist
\item
  \texttt{dtypes}: A list of types. The length of dtypes must equal the
  number of tensors in each element.
\item
  \texttt{shapes}: Constraints on the shapes of tensors in an element: A
  list of shape tuples or None. This list is the same length as dtypes.
  If the shape of any tensors in the element are constrained, all must
  be; shapes can be None if the shapes should not be constrained.
\item
  \texttt{queue\_ref}: The queue reference, i.e.~the output of the queue
  op.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.QueueBase.dtypes}
}{tf.QueueBase.dtypes }}\label{tf.queuebase.dtypes}

The list of dtypes for each component of a queue element.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.QueueBase.name}
}{tf.QueueBase.name }}\label{tf.queuebase.name}

The name of the underlying queue.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.QueueBase.queue\_ref}
}{tf.QueueBase.queue\_ref }}\label{tf.queuebase.queueux5fref}

The underlying queue reference.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.FIFOQueue}
}{class tf.FIFOQueue }}\label{class-tf.fifoqueue}

A queue implementation that dequeues elements in first-in-first out
order.

See \protect\hyperlink{QueueBase}{\texttt{tf.QueueBase}} for a
description of the methods on this class.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.FIFOQueue.\_\_init\_\_(capacity,\ dtypes,\ shapes=None,\ shared\_name=None,\ name=\textquotesingle{}fifo\_queue\textquotesingle{})}
}{tf.FIFOQueue.\_\_init\_\_(capacity, dtypes, shapes=None, shared\_name=None, name='fifo\_queue') }}\label{tf.fifoqueue.ux5fux5finitux5fux5fcapacity-dtypes-shapesnone-sharedux5fnamenone-namefifoux5fqueue}

Creates a queue that dequeues elements in a first-in first-out order.

A \texttt{FIFOQueue} has bounded capacity; supports multiple concurrent
producers and consumers; and provides exactly-once delivery.

A \texttt{FIFOQueue} holds a list of up to \texttt{capacity} elements.
Each element is a fixed-length tuple of tensors whose dtypes are
described by \texttt{dtypes}, and whose shapes are optionally described
by the \texttt{shapes} argument.

If the \texttt{shapes} argument is specified, each component of a queue
element must have the respective fixed shape. If it is unspecified,
different queue elements may have different shapes, but the use of
\texttt{dequeue\_many} is disallowed.

\subparagraph{Args: }\label{args-54}

\begin{itemize}
\tightlist
\item
  \texttt{capacity}: An integer. The upper bound on the number of
  elements that may be stored in this queue.
\item
  \texttt{dtypes}: A list of \texttt{DType} objects. The length of
  \texttt{dtypes} must equal the number of tensors in each queue
  element.
\item
  \texttt{shapes}: (Optional.) A list of fully-defined
  \texttt{TensorShape} objects, with the same length as \texttt{dtypes}
  or \texttt{None}.
\item
  \texttt{shared\_name}: (Optional.) If non-empty, this queue will be
  shared under the given name across multiple sessions.
\item
  \texttt{name}: Optional name for the queue operation.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.RandomShuffleQueue}
}{class tf.RandomShuffleQueue }}\label{class-tf.randomshufflequeue}

A queue implementation that dequeues elements in a random order.

See \protect\hyperlink{QueueBase}{\texttt{tf.QueueBase}} for a
description of the methods on this class.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.RandomShuffleQueue.\_\_init\_\_(capacity,\ min\_after\_dequeue,\ dtypes,\ shapes=None,\ seed=None,\ shared\_name=None,\ name=\textquotesingle{}random\_shuffle\_queue\textquotesingle{})}
}{tf.RandomShuffleQueue.\_\_init\_\_(capacity, min\_after\_dequeue, dtypes, shapes=None, seed=None, shared\_name=None, name='random\_shuffle\_queue') }}\label{tf.randomshufflequeue.ux5fux5finitux5fux5fcapacity-minux5fafterux5fdequeue-dtypes-shapesnone-seednone-sharedux5fnamenone-namerandomux5fshuffleux5fqueue}

Create a queue that dequeues elements in a random order.

A \texttt{RandomShuffleQueue} has bounded capacity; supports multiple
concurrent producers and consumers; and provides exactly-once delivery.

A \texttt{RandomShuffleQueue} holds a list of up to \texttt{capacity}
elements. Each element is a fixed-length tuple of tensors whose dtypes
are described by \texttt{dtypes}, and whose shapes are optionally
described by the \texttt{shapes} argument.

If the \texttt{shapes} argument is specified, each component of a queue
element must have the respective fixed shape. If it is unspecified,
different queue elements may have different shapes, but the use of
\texttt{dequeue\_many} is disallowed.

The \texttt{min\_after\_dequeue} argument allows the caller to specify a
minimum number of elements that will remain in the queue after a
\texttt{dequeue} or \texttt{dequeue\_many} operation completes, to
ensure a minimum level of mixing of elements. This invariant is
maintained by blocking those operations until sufficient elements have
been enqueued. The \texttt{min\_after\_dequeue} argument is ignored
after the queue has been closed.

\subparagraph{Args: }\label{args-55}

\begin{itemize}
\tightlist
\item
  \texttt{capacity}: An integer. The upper bound on the number of
  elements that may be stored in this queue.
\item
  \texttt{min\_after\_dequeue}: An integer (described above).
\item
  \texttt{dtypes}: A list of \texttt{DType} objects. The length of
  \texttt{dtypes} must equal the number of tensors in each queue
  element.
\item
  \texttt{shapes}: (Optional.) A list of fully-defined
  \texttt{TensorShape} objects, with the same length as \texttt{dtypes}
  or \texttt{None}.
\item
  \texttt{seed}: A Python integer. Used to create a random seed. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
  for behavior.
\item
  \texttt{shared\_name}: (Optional.) If non-empty, this queue will be
  shared under the given name across multiple sessions.
\item
  \texttt{name}: Optional name for the queue operation.
\end{itemize}

\subsection{Dealing with the filesystem
}\label{dealing-with-the-filesystem}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.matching\_files(pattern,\ name=None)}
}{tf.matching\_files(pattern, name=None) }}\label{tf.matchingux5ffilespattern-namenone}

Returns the set of files matching a pattern.

Note that this routine only supports wildcard characters in the basename
portion of the pattern, not in the directory portion.

\subparagraph{Args: }\label{args-56}

\begin{itemize}
\tightlist
\item
  \texttt{pattern}: A \texttt{Tensor} of type \texttt{string}. A
  (scalar) shell wildcard pattern.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-47}

A \texttt{Tensor} of type \texttt{string}. A vector of matching
filenames.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.read\_file(filename,\ name=None)}
}{tf.read\_file(filename, name=None) }}\label{tf.readux5ffilefilename-namenone}

Reads and outputs the entire contents of the input filename.

\subparagraph{Args: }\label{args-57}

\begin{itemize}
\tightlist
\item
  \texttt{filename}: A \texttt{Tensor} of type \texttt{string}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-48}

A \texttt{Tensor} of type \texttt{string}.

\subsection{Input pipeline }\label{input-pipeline}

TensorFlow functions for setting up an input-prefetching pipeline.
Please see the \href{../../how_tos/reading_data/index.md}{reading data
how-to} for context.

\subsubsection{Beginning of an input pipeline
}\label{beginning-of-an-input-pipeline}

The ``producer'' functions add a queue to the graph and a corresponding
\texttt{QueueRunner} for running the subgraph that fills that queue.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.match\_filenames\_once(pattern,\ name=None)}
}{tf.train.match\_filenames\_once(pattern, name=None) }}\label{tf.train.matchux5ffilenamesux5foncepattern-namenone}

Save the list of files matching pattern, so it is only computed once.

\subparagraph{Args: }\label{args-58}

\begin{itemize}
\tightlist
\item
  \texttt{pattern}: A file pattern (glob).
\item
  \texttt{name}: A name for the operations (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-49}

A variable that is initialized to the list of files matching pattern.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.limit\_epochs(tensor,\ num\_epochs=None,\ name=None)}
}{tf.train.limit\_epochs(tensor, num\_epochs=None, name=None) }}\label{tf.train.limitux5fepochstensor-numux5fepochsnone-namenone}

Returns tensor num\_epochs times and then raises an OutOfRange error.

\subparagraph{Args: }\label{args-59}

\begin{itemize}
\tightlist
\item
  \texttt{tensor}: Any Tensor.
\item
  \texttt{num\_epochs}: An integer (optional). If specified, limits the
  number of steps the output tensor may be evaluated.
\item
  \texttt{name}: A name for the operations (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-50}

tensor or OutOfRange.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.range\_input\_producer(limit,\ num\_epochs=None,\ shuffle=True,\ seed=None,\ capacity=32,\ name=None)}
}{tf.train.range\_input\_producer(limit, num\_epochs=None, shuffle=True, seed=None, capacity=32, name=None) }}\label{tf.train.rangeux5finputux5fproducerlimit-numux5fepochsnone-shuffletrue-seednone-capacity32-namenone}

Produces the integers from 0 to limit-1 in a queue.

\subparagraph{Args: }\label{args-60}

\begin{itemize}
\tightlist
\item
  \texttt{limit}: An int32 scalar tensor.
\item
  \texttt{num\_epochs}: An integer (optional). If specified,
  \texttt{range\_input\_producer} produces each integer
  \texttt{num\_epochs} times before generating an OutOfRange error. If
  not specified, \texttt{range\_input\_producer} can cycle through the
  integers an unlimited number of times.
\item
  \texttt{shuffle}: Boolean. If true, the integers are randomly shuffled
  within each epoch.
\item
  \texttt{seed}: An integer (optional). Seed used if shuffle == True.
\item
  \texttt{capacity}: An integer. Sets the queue capacity.
\item
  \texttt{name}: A name for the operations (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-51}

A Queue with the output integers. A QueueRunner for the Queue is added
to the current Graph's QUEUE\_RUNNER collection.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.slice\_input\_producer(tensor\_list,\ num\_epochs=None,\ shuffle=True,\ seed=None,\ capacity=32,\ name=None)}
}{tf.train.slice\_input\_producer(tensor\_list, num\_epochs=None, shuffle=True, seed=None, capacity=32, name=None) }}\label{tf.train.sliceux5finputux5fproducertensorux5flist-numux5fepochsnone-shuffletrue-seednone-capacity32-namenone}

Produces a slice of each Tensor in tensor\_list.

Implemented using a Queue -- a QueueRunner for the Queue is added to the
current Graph's QUEUE\_RUNNER collection.

\subparagraph{Args: }\label{args-61}

\begin{itemize}
\tightlist
\item
  \texttt{tensor\_list}: A list of Tensors. Every Tensor in tensor\_list
  must have the same size in the first dimension.
\item
  \texttt{num\_epochs}: An integer (optional). If specified,
  \texttt{slice\_input\_producer} produces each slice
  \texttt{num\_epochs} times before generating an OutOfRange error. If
  not specified, \texttt{slice\_input\_producer} can cycle through the
  slices an unlimited number of times.
\item
  \texttt{seed}: An integer (optional). Seed used if shuffle == True.
\item
  \texttt{capacity}: An integer. Sets the queue capacity.
\item
  \texttt{name}: A name for the operations (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-52}

A list of tensors, one for each element of tensor\_list. If the tensor
in tensor\_list has shape {[}N, a, b, .., z{]}, then the corresponding
output tensor will have shape {[}a, b, \ldots{}, z{]}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.string\_input\_producer(string\_tensor,\ num\_epochs=None,\ shuffle=True,\ seed=None,\ capacity=32,\ name=None)}
}{tf.train.string\_input\_producer(string\_tensor, num\_epochs=None, shuffle=True, seed=None, capacity=32, name=None) }}\label{tf.train.stringux5finputux5fproducerstringux5ftensor-numux5fepochsnone-shuffletrue-seednone-capacity32-namenone}

Output strings (e.g.~filenames) to a queue for an input pipeline.

\subparagraph{Args: }\label{args-62}

\begin{itemize}
\tightlist
\item
  \texttt{string\_tensor}: A 1-D string tensor with the strings to
  produce.
\item
  \texttt{num\_epochs}: An integer (optional). If specified,
  \texttt{string\_input\_producer} produces each string from
  \texttt{string\_tensor} \texttt{num\_epochs} times before generating
  an OutOfRange error. If not specified,
  \texttt{string\_input\_producer} can cycle through the strings in
  \texttt{string\_tensor} an unlimited number of times.
\item
  \texttt{shuffle}: Boolean. If true, the strings are randomly shuffled
  within each epoch.
\item
  \texttt{seed}: An integer (optional). Seed used if shuffle == True.
\item
  \texttt{capacity}: An integer. Sets the queue capacity.
\item
  \texttt{name}: A name for the operations (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-53}

A queue with the output strings. A QueueRunner for the Queue is added to
the current Graph's QUEUE\_RUNNER collection.

\subsubsection{Batching at the end of an input pipeline
}\label{batching-at-the-end-of-an-input-pipeline}

These functions add a queue to the graph to assemble a batch of
examples, with possible shuffling. They also add a \texttt{QueueRunner}
for running the subgraph that fills that queue.

Use \protect\hyperlink{batch}{batch} or
\protect\hyperlink{batchux5fjoin}{batch\_join} for batching examples
that have already been well shuffled. Use
\protect\hyperlink{shuffleux5fbatch}{shuffle\_batch} or
\protect\hyperlink{shuffleux5fbatchux5fjoin}{shuffle\_batch\_join} for
examples that would benefit from additional shuffling.

Use \protect\hyperlink{batch}{batch} or
\protect\hyperlink{shuffleux5fbatch}{shuffle\_batch} if you want a
single thread producing examples to batch, or if you have a single
subgraph producing examples but you want to run it in N threads (where
you increase N until it can keep the queue full). Use
\protect\hyperlink{batchux5fjoin}{batch\_join} or
\protect\hyperlink{shuffleux5fbatchux5fjoin}{shuffle\_batch\_join} if
you have N different subgraphs producing examples to batch and you want
them run by N threads.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.batch(tensor\_list,\ batch\_size,\ num\_threads=1,\ capacity=32,\ enqueue\_many=False,\ shapes=None,\ name=None)}
}{tf.train.batch(tensor\_list, batch\_size, num\_threads=1, capacity=32, enqueue\_many=False, shapes=None, name=None) }}\label{tf.train.batchtensorux5flist-batchux5fsize-numux5fthreads1-capacity32-enqueueux5fmanyfalse-shapesnone-namenone}

Creates batches of tensors in \texttt{tensor\_list}.

This function is implemented using a queue. A \texttt{QueueRunner} for
the queue is added to the current \texttt{Graph}'s
\texttt{QUEUE\_RUNNER} collection.

If \texttt{enqueue\_many} is \texttt{False}, \texttt{tensor\_list} is
assumed to represent a single example. An input tensor with shape
\texttt{{[}x,\ y,\ z{]}} will be output as a tensor with shape
\texttt{{[}batch\_size,\ x,\ y,\ z{]}}.

If \texttt{enqueue\_many} is \texttt{True}, \texttt{tensor\_list} is
assumed to represent a batch of examples, where the first dimension is
indexed by example, and all members of \texttt{tensor\_list} should have
the same size in the first dimension. If an input tensor has shape
\texttt{{[}*,\ x,\ y,\ z{]}}, the output will have shape
\texttt{{[}batch\_size,\ x,\ y,\ z{]}}. The \texttt{capacity} argument
controls the how long the prefetching is allowed to grow the queues.

\subparagraph{Args: }\label{args-63}

\begin{itemize}
\tightlist
\item
  \texttt{tensor\_list}: The list of tensors to enqueue.
\item
  \texttt{batch\_size}: The new batch size pulled from the queue.
\item
  \texttt{num\_threads}: The number of threads enqueuing
  \texttt{tensor\_list}.
\item
  \texttt{capacity}: An integer. The maximum number of elements in the
  queue.
\item
  \texttt{enqueue\_many}: Whether each tensor in \texttt{tensor\_list}
  is a single example.
\item
  \texttt{shapes}: (Optional) The shapes for each example. Defaults to
  the inferred shapes for \texttt{tensor\_list}.
\item
  \texttt{name}: (Optional) A name for the operations.
\end{itemize}

\subparagraph{Returns: }\label{returns-54}

A list of tensors with the same number and types as
\texttt{tensor\_list}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.batch\_join(tensor\_list\_list,\ batch\_size,\ capacity=32,\ enqueue\_many=False,\ shapes=None,\ name=None)}
}{tf.train.batch\_join(tensor\_list\_list, batch\_size, capacity=32, enqueue\_many=False, shapes=None, name=None) }}\label{tf.train.batchux5fjointensorux5flistux5flist-batchux5fsize-capacity32-enqueueux5fmanyfalse-shapesnone-namenone}

Runs a list of tensors to fill a queue to create batches of examples.

Enqueues a different list of tensors in different threads. Implemented
using a queue -- a \texttt{QueueRunner} for the queue is added to the
current \texttt{Graph}'s \texttt{QUEUE\_RUNNER} collection.

\texttt{len(tensor\_list\_list)} threads will be started, with thread
\texttt{i} enqueuing the tensors from
\texttt{tensor\_list\_list{[}i{]}}.
\texttt{tensor\_list\_list{[}i1{]}{[}j{]}} must match
\texttt{tensor\_list\_list{[}i2{]}{[}j{]}} in type and shape, except in
the first dimension if \texttt{enqueue\_many} is true.

If \texttt{enqueue\_many} is \texttt{False}, each
\texttt{tensor\_list\_list{[}i{]}} is assumed to represent a single
example. An input tensor \texttt{x} will be output as a tensor with
shape \texttt{{[}batch\_size{]}\ +\ x.shape}.

If \texttt{enqueue\_many} is \texttt{True},
\texttt{tensor\_list\_list{[}i{]}} is assumed to represent a batch of
examples, where the first dimension is indexed by example, and all
members of \texttt{tensor\_list\_list{[}i{]}} should have the same size
in the first dimension. The slices of any input tensor \texttt{x} are
treated as examples, and the output tensors will have shape
\texttt{{[}batch\_size{]}\ +\ x.shape{[}1:{]}}.

The \texttt{capacity} argument controls the how long the prefetching is
allowed to grow the queues.

\subparagraph{Args: }\label{args-64}

\begin{itemize}
\tightlist
\item
  \texttt{tensor\_list\_list}: A list of tuples of tensors to enqueue.
\item
  \texttt{batch\_size}: An integer. The new batch size pulled from the
  queue.
\item
  \texttt{capacity}: An integer. The maximum number of elements in the
  queue.
\item
  \texttt{enqueue\_many}: Whether each tensor in
  \texttt{tensor\_list\_list} is a single example.
\item
  \texttt{shapes}: (Optional) The shapes for each example. Defaults to
  the inferred shapes for \texttt{tensor\_list\_list{[}i{]}}.
\item
  \texttt{name}: (Optional) A name for the operations.
\end{itemize}

\subparagraph{Returns: }\label{returns-55}

A list of tensors with the same number and types as
\texttt{tensor\_list\_list{[}i{]}}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.shuffle\_batch(tensor\_list,\ batch\_size,\ capacity,\ min\_after\_dequeue,\ num\_threads=1,\ seed=None,\ enqueue\_many=False,\ shapes=None,\ name=None)}
}{tf.train.shuffle\_batch(tensor\_list, batch\_size, capacity, min\_after\_dequeue, num\_threads=1, seed=None, enqueue\_many=False, shapes=None, name=None) }}\label{tf.train.shuffleux5fbatchtensorux5flist-batchux5fsize-capacity-minux5fafterux5fdequeue-numux5fthreads1-seednone-enqueueux5fmanyfalse-shapesnone-namenone}

Creates batches by randomly shuffling tensors.

This function adds the following to the current \texttt{Graph}:

\begin{itemize}
\tightlist
\item
  A shuffling queue into which tensors from \texttt{tensor\_list} are
  enqueued.
\item
  A \texttt{dequeue\_many} operation to create batches from the queue.
\item
  A \texttt{QueueRunner} to \texttt{QUEUE\_RUNNER} collection, to
  enqueue the tensors from \texttt{tensor\_list}.
\end{itemize}

If \texttt{enqueue\_many} is \texttt{False}, \texttt{tensor\_list} is
assumed to represent a single example. An input tensor with shape
\texttt{{[}x,\ y,\ z{]}} will be output as a tensor with shape
\texttt{{[}batch\_size,\ x,\ y,\ z{]}}.

If \texttt{enqueue\_many} is \texttt{True}, \texttt{tensor\_list} is
assumed to represent a batch of examples, where the first dimension is
indexed by example, and all members of \texttt{tensor\_list} should have
the same size in the first dimension. If an input tensor has shape
\texttt{{[}*,\ x,\ y,\ z{]}}, the output will have shape
\texttt{{[}batch\_size,\ x,\ y,\ z{]}}.

The \texttt{capacity} argument controls the how long the prefetching is
allowed to grow the queues.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Creates batches of 32 images and 32 labels.}
\NormalTok{image_batch, label_batch }\OperatorTok{=} \NormalTok{tf.train.shuffle_batch(}
      \NormalTok{[single_image, single_label],}
      \NormalTok{batch_size}\OperatorTok{=}\DecValTok{32}\NormalTok{,}
      \NormalTok{num_threads}\OperatorTok{=}\DecValTok{4}\NormalTok{,}
      \NormalTok{capacity}\OperatorTok{=}\DecValTok{50000}\NormalTok{,}
      \NormalTok{min_after_dequeue}\OperatorTok{=}\DecValTok{10000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-65}

\begin{itemize}
\tightlist
\item
  \texttt{tensor\_list}: The list of tensors to enqueue.
\item
  \texttt{batch\_size}: The new batch size pulled from the queue.
\item
  \texttt{capacity}: An integer. The maximum number of elements in the
  queue.
\item
  \texttt{min\_after\_dequeue}: Minimum number elements in the queue
  after a dequeue, used to ensure a level of mixing of elements.
\item
  \texttt{num\_threads}: The number of threads enqueuing
  \texttt{tensor\_list}.
\item
  \texttt{seed}: Seed for the random shuffling within the queue.
\item
  \texttt{enqueue\_many}: Whether each tensor in \texttt{tensor\_list}
  is a single example.
\item
  \texttt{shapes}: (Optional) The shapes for each example. Defaults to
  the inferred shapes for \texttt{tensor\_list}.
\item
  \texttt{name}: (Optional) A name for the operations.
\end{itemize}

\subparagraph{Returns: }\label{returns-56}

A list of tensors with the same number and types as
\texttt{tensor\_list}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.shuffle\_batch\_join(tensor\_list\_list,\ batch\_size,\ capacity,\ min\_after\_dequeue,\ seed=None,\ enqueue\_many=False,\ shapes=None,\ name=None)}
}{tf.train.shuffle\_batch\_join(tensor\_list\_list, batch\_size, capacity, min\_after\_dequeue, seed=None, enqueue\_many=False, shapes=None, name=None) }}\label{tf.train.shuffleux5fbatchux5fjointensorux5flistux5flist-batchux5fsize-capacity-minux5fafterux5fdequeue-seednone-enqueueux5fmanyfalse-shapesnone-namenone}

Create batches by randomly shuffling tensors.

This version enqueues a different list of tensors in different threads.
It adds the following to the current \texttt{Graph}:

\begin{itemize}
\tightlist
\item
  A shuffling queue into which tensors from \texttt{tensor\_list\_list}
  are enqueued.
\item
  A \texttt{dequeue\_many} operation to create batches from the queue.
\item
  A \texttt{QueueRunner} to \texttt{QUEUE\_RUNNER} collection, to
  enqueue the tensors from \texttt{tensor\_list\_list}.
\end{itemize}

\texttt{len(tensor\_list\_list)} threads will be started, with thread
\texttt{i} enqueuing the tensors from
\texttt{tensor\_list\_list{[}i{]}}.
\texttt{tensor\_list\_list{[}i1{]}{[}j{]}} must match
\texttt{tensor\_list\_list{[}i2{]}{[}j{]}} in type and shape, except in
the first dimension if \texttt{enqueue\_many} is true.

If \texttt{enqueue\_many} is \texttt{False}, each
\texttt{tensor\_list\_list{[}i{]}} is assumed to represent a single
example. An input tensor with shape \texttt{{[}x,\ y,\ z{]}} will be
output as a tensor with shape \texttt{{[}batch\_size,\ x,\ y,\ z{]}}.

If \texttt{enqueue\_many} is \texttt{True},
\texttt{tensor\_list\_list{[}i{]}} is assumed to represent a batch of
examples, where the first dimension is indexed by example, and all
members of \texttt{tensor\_list\_list{[}i{]}} should have the same size
in the first dimension. If an input tensor has shape
\texttt{{[}*,\ x,\ y,\ z{]}}, the output will have shape
\texttt{{[}batch\_size,\ x,\ y,\ z{]}}.

The \texttt{capacity} argument controls the how long the prefetching is
allowed to grow the queues.

\subparagraph{Args: }\label{args-66}

\begin{itemize}
\tightlist
\item
  \texttt{tensor\_list\_list}: A list of tuples of tensors to enqueue.
\item
  \texttt{batch\_size}: An integer. The new batch size pulled from the
  queue.
\item
  \texttt{capacity}: An integer. The maximum number of elements in the
  queue.
\item
  \texttt{min\_after\_dequeue}: Minimum number elements in the queue
  after a dequeue, used to ensure a level of mixing of elements.
\item
  \texttt{seed}: Seed for the random shuffling within the queue.
\item
  \texttt{enqueue\_many}: Whether each tensor in
  \texttt{tensor\_list\_list} is a single example.
\item
  \texttt{shapes}: (Optional) The shapes for each example. Defaults to
  the inferred shapes for \texttt{tensor\_list\_list{[}i{]}}.
\item
  \texttt{name}: (Optional) A name for the operations.
\end{itemize}

\subparagraph{Returns: }\label{returns-57}

A list of tensors with the same number and types as
\texttt{tensor\_list\_list{[}i{]}}.
