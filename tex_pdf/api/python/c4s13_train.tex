

\section{Training }\label{training}

\subsection{Contents}\label{contents}

\subsubsection{\texorpdfstring{\protect\hyperlink{AUTOGENERATED-training}{Training}}{Training}}\label{training-1}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{AUTOGENERATED-optimizers}{Optimizers}
\item
  \protect\hyperlink{Optimizer}{\texttt{class\ tf.train.Optimizer}}
\item
  \protect\hyperlink{AUTOGENERATED-usage}{Usage}
\item
  \protect\hyperlink{AUTOGENERATED-processing-gradients-before-applying-them.}{Processing
  gradients before applying them.}
\item
  \protect\hyperlink{AUTOGENERATED-gating-gradients}{Gating Gradients}
\item
  \protect\hyperlink{AUTOGENERATED-slots}{Slots}
\item
  \protect\hyperlink{GradientDescentOptimizer}{\texttt{class\ tf.train.GradientDescentOptimizer}}
\item
  \protect\hyperlink{AdagradOptimizer}{\texttt{class\ tf.train.AdagradOptimizer}}
\item
  \protect\hyperlink{MomentumOptimizer}{\texttt{class\ tf.train.MomentumOptimizer}}
\item
  \protect\hyperlink{AdamOptimizer}{\texttt{class\ tf.train.AdamOptimizer}}
\item
  \protect\hyperlink{FtrlOptimizer}{\texttt{class\ tf.train.FtrlOptimizer}}
\item
  \protect\hyperlink{RMSPropOptimizer}{\texttt{class\ tf.train.RMSPropOptimizer}}
\item
  \protect\hyperlink{AUTOGENERATED-gradient-computation}{Gradient
  Computation}
\item
  \protect\hyperlink{gradients}{\texttt{tf.gradients(ys,\ xs,\ grad\_ys=None,\ name=\textquotesingle{}gradients\textquotesingle{},\ colocate\_gradients\_with\_ops=False,\ gate\_gradients=False,\ aggregation\_method=None)}}
\item
  \protect\hyperlink{AggregationMethod}{\texttt{class\ tf.AggregationMethod}}
\item
  \protect\hyperlink{stopux5fgradient}{\texttt{tf.stop\_gradient(input,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-gradient-clipping}{Gradient Clipping}
\item
  \protect\hyperlink{clipux5fbyux5fvalue}{\texttt{tf.clip\_by\_value(t,\ clip\_value\_min,\ clip\_value\_max,\ name=None)}}
\item
  \protect\hyperlink{clipux5fbyux5fnorm}{\texttt{tf.clip\_by\_norm(t,\ clip\_norm,\ name=None)}}
\item
  \protect\hyperlink{clipux5fbyux5faverageux5fnorm}{\texttt{tf.clip\_by\_average\_norm(t,\ clip\_norm,\ name=None)}}
\item
  \protect\hyperlink{clipux5fbyux5fglobalux5fnorm}{\texttt{tf.clip\_by\_global\_norm(t\_list,\ clip\_norm,\ use\_norm=None,\ name=None)}}
\item
  \protect\hyperlink{globalux5fnorm}{\texttt{tf.global\_norm(t\_list,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-decaying-the-learning-rate}{Decaying
  the learning rate}
\item
  \protect\hyperlink{exponentialux5fdecay}{\texttt{tf.train.exponential\_decay(learning\_rate,\ global\_step,\ decay\_steps,\ decay\_rate,\ staircase=False,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-moving-averages}{Moving Averages}
\item
  \protect\hyperlink{ExponentialMovingAverage}{\texttt{class\ tf.train.ExponentialMovingAverage}}
\item
  \protect\hyperlink{AUTOGENERATED-coordinator-and-queuerunner}{Coordinator
  and QueueRunner}
\item
  \protect\hyperlink{Coordinator}{\texttt{class\ tf.train.Coordinator}}
\item
  \protect\hyperlink{QueueRunner}{\texttt{class\ tf.train.QueueRunner}}
\item
  \protect\hyperlink{addux5fqueueux5frunner}{\texttt{tf.train.add\_queue\_runner(qr,\ collection=\textquotesingle{}queue\_runners\textquotesingle{})}}
\item
  \protect\hyperlink{startux5fqueueux5frunners}{\texttt{tf.train.start\_queue\_runners(sess=None,\ coord=None,\ daemon=True,\ start=True,\ collection=\textquotesingle{}queue\_runners\textquotesingle{})}}
\item
  \protect\hyperlink{AUTOGENERATED-summary-operations}{Summary
  Operations}
\item
  \protect\hyperlink{scalarux5fsummary}{\texttt{tf.scalar\_summary(tags,\ values,\ collections=None,\ name=None)}}
\item
  \protect\hyperlink{imageux5fsummary}{\texttt{tf.image\_summary(tag,\ tensor,\ max\_images=None,\ collections=None,\ name=None)}}
\item
  \protect\hyperlink{histogramux5fsummary}{\texttt{tf.histogram\_summary(tag,\ values,\ collections=None,\ name=None)}}
\item
  \protect\hyperlink{zeroux5ffraction}{\texttt{tf.nn.zero\_fraction(value,\ name=None)}}
\item
  \protect\hyperlink{mergeux5fsummary}{\texttt{tf.merge\_summary(inputs,\ collections=None,\ name=None)}}
\item
  \protect\hyperlink{mergeux5fallux5fsummaries}{\texttt{tf.merge\_all\_summaries(key=\textquotesingle{}summaries\textquotesingle{})}}
\item
  \protect\hyperlink{AUTOGENERATED-adding-summaries-to-event-files}{Adding
  Summaries to Event Files}
\item
  \protect\hyperlink{SummaryWriter}{\texttt{class\ tf.train.SummaryWriter}}
\item
  \protect\hyperlink{summaryux5fiterator}{\texttt{tf.train.summary\_iterator(path)}}
\item
  \protect\hyperlink{AUTOGENERATED-training-utilities}{Training
  utilities}
\item
  \protect\hyperlink{globalux5fstep}{\texttt{tf.train.global\_step(sess,\ global\_step\_tensor)}}
\item
  \protect\hyperlink{writeux5fgraph}{\texttt{tf.train.write\_graph(graph\_def,\ logdir,\ name,\ as\_text=True)}}
\end{itemize}

This library provides a set of classes and functions that helps train
models.

\subsection{Optimizers }\label{optimizers}

The Optimizer base class provides methods to compute gradients for a
loss and apply gradients to variables. A collection of subclasses
implement classic optimization algorithms such as GradientDescent and
Adagrad.

You never instantiate the Optimizer class itself, but instead
instantiate one of the subclasses.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.train.Optimizer}
}{class tf.train.Optimizer }}\label{class-tf.train.optimizer}

Base class for optimizers.

This class defines the API to add Ops to train a model. You never use
this class directly, but instead instantiate one of its subclasses such
as \texttt{GradientDescentOptimizer}, \texttt{AdagradOptimizer}, or
\texttt{MomentumOptimizer}.

\subsubsection{Usage }\label{usage}

\begin{verbatim}
# Create an optimizer with the desired parameters.
opt = GradientDescentOptimizer(learning_rate=0.1)
# Add Ops to the graph to minimize a cost by updating a list of variables.
# "cost" is a Tensor, and the list of variables contains variables.Variable
# objects.
opt_op = opt.minimize(cost, <list of variables>)
\end{verbatim}

In the training program you will just have to run the returned Op.

\begin{verbatim}
# Execute opt_op to do one step of training:
opt_op.run()
\end{verbatim}

\subsubsection{Processing gradients before applying them.
}\label{processing-gradients-before-applying-them.}

Calling \texttt{minimize()} takes care of both computing the gradients
and applying them to the variables. If you want to process the gradients
before applying them you can instead use the optimizer in three steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compute the gradients with \texttt{compute\_gradients()}.
\item
  Process the gradients as you wish.
\item
  Apply the processed gradients with \texttt{apply\_gradients()}.
\end{enumerate}

Example:

\begin{verbatim}
# Create an optimizer.
opt = GradientDescentOptimizer(learning_rate=0.1)

# Compute the gradients for a list of variables.
grads_and_vars = opt.compute_gradients(loss, <list of variables>)

# grads_and_vars is a list of tuples (gradient, variable).  Do whatever you
# need to the 'gradient' part, for example cap them, etc.
capped_grads_and_vars = [(MyCapper(gv[0]), gv[1])) for gv in grads_and_vars]

# Ask the optimizer to apply the capped gradients.
opt.apply_gradients(capped_grads_and_vars)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.Optimizer.\_\_init\_\_(use\_locking,\ name)}
}{tf.train.Optimizer.\_\_init\_\_(use\_locking, name) }}\label{tf.train.optimizer.ux5fux5finitux5fux5fuseux5flocking-name}

Create a new Optimizer.

This must be called by the constructors of subclasses.

\subparagraph{Args: }\label{args}

\begin{itemize}
\tightlist
\item
  \texttt{use\_locking}: Bool. If True apply use locks to prevent
  concurrent updates to variables.
\item
  \texttt{name}: A non-empty string. The name to use for accumulators
  created for the optimizer.
\end{itemize}

\subparagraph{Raises: }\label{raises}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if name is malformed.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.Optimizer.minimize(loss,\ global\_step=None,\ var\_list=None,\ gate\_gradients=1,\ name=None)}
}{tf.train.Optimizer.minimize(loss, global\_step=None, var\_list=None, gate\_gradients=1, name=None) }}\label{tf.train.optimizer.minimizeloss-globalux5fstepnone-varux5flistnone-gateux5fgradients1-namenone}

Add operations to minimize `loss' by updating `var\_list'.

This method simply combines calls compute\_gradients() and
apply\_gradients(). If you want to process the gradient before applying
them call compute\_gradients() and apply\_gradients() explicitly instead
of using this function.

\subparagraph{Args: }\label{args-1}

\begin{itemize}
\tightlist
\item
  \texttt{loss}: A Tensor containing the value to minimize.
\item
  \texttt{global\_step}: Optional Variable to increment by one after the
  variables have been updated.
\item
  \texttt{var\_list}: Optional list of variables.Variable to update to
  minimize `loss'. Defaults to the list of variables collected in the
  graph under the key GraphKeys.TRAINABLE\_VARIABLES.
\item
  \texttt{gate\_gradients}: How to gate the computation of gradients.
  Can be GATE\_NONE, GATE\_OP, or GATE\_GRAPH.
\item
  \texttt{name}: Optional name for the returned operation.
\end{itemize}

\subparagraph{Returns: }\label{returns}

An Operation that updates the variables in `var\_list'. If
`global\_step' was not None, that operation also increments
global\_step.

\subparagraph{Raises: }\label{raises-1}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if some of the variables are not
  variables.Variable objects.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.Optimizer.compute\_gradients(loss,\ var\_list=None,\ gate\_gradients=1)}
}{tf.train.Optimizer.compute\_gradients(loss, var\_list=None, gate\_gradients=1) }}\label{tf.train.optimizer.computeux5fgradientsloss-varux5flistnone-gateux5fgradients1}

Compute gradients of ``loss'' for the variables in ``var\_list''.

This is the first part of minimize(). It returns a list of (gradient,
variable) pairs where ``gradient'' is the gradient for ``variable''.
Note that ``gradient'' can be a Tensor, a IndexedSlices, or None if
there is no gradient for the given variable.

\subparagraph{Args: }\label{args-2}

\begin{itemize}
\tightlist
\item
  \texttt{loss}: A Tensor containing the value to minimize.
\item
  \texttt{var\_list}: Optional list of variables.Variable to update to
  minimize ``loss''. Defaults to the list of variables collected in the
  graph under the key GraphKey.TRAINABLE\_VARIABLES.
\item
  \texttt{gate\_gradients}: How to gate the computation of gradients.
  Can be GATE\_NONE, GATE\_OP, or GATE\_GRAPH.
\end{itemize}

\subparagraph{Returns: }\label{returns-1}

A list of (gradient, variable) pairs.

\subparagraph{Raises: }\label{raises-2}

\begin{itemize}
\tightlist
\item
  \texttt{TypeError}: If var\_list contains anything else than
  variables.Variable.
\item
  \texttt{ValueError}: If some arguments are invalid.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.Optimizer.apply\_gradients(grads\_and\_vars,\ global\_step=None,\ name=None)}
}{tf.train.Optimizer.apply\_gradients(grads\_and\_vars, global\_step=None, name=None) }}\label{tf.train.optimizer.applyux5fgradientsgradsux5fandux5fvars-globalux5fstepnone-namenone}

Apply gradients to variables.

This is the second part of minimize(). It returns an Operation that
applies gradients.

\subparagraph{Args: }\label{args-3}

\begin{itemize}
\tightlist
\item
  \texttt{grads\_and\_vars}: List of (gradient, variable) pairs as
  returned by compute\_gradients().
\item
  \texttt{global\_step}: Optional Variable to increment by one after the
  variables have been updated.
\item
  \texttt{name}: Optional name for the returned operation. Default to
  the name passed to the Optimizer constructor.
\end{itemize}

\subparagraph{Returns: }\label{returns-2}

An Operation that applies the specified gradients. If `global\_step' was
not None, that operation also increments global\_step.

\subparagraph{Raises: }\label{raises-3}

\begin{itemize}
\tightlist
\item
  \texttt{TypeError}: if grads\_and\_vars is malformed.
\end{itemize}

\subsubsection{Gating Gradients }\label{gating-gradients}

Both \texttt{minimize()} and \texttt{compute\_gradients()} accept a
\texttt{gate\_gradient} argument that controls the degree of parallelism
during the application of the gradients.

The possible values are: \texttt{GATE\_NONE}, \texttt{GATE\_OP}, and
\texttt{GATE\_GRAPH}.

GATE\_NONE: Compute and apply gradients in parallel. This provides the
maximum parallelism in execution, at the cost of some
non-reproducibility in the results. For example the two gradients of
MatMul depend on the input values: With \texttt{GATE\_NONE} one of the
gradients could be applied to one of the inputs \emph{before} the other
gradient is computed resulting in non-reproducible results.

GATE\_OP: For each Op, make sure all gradients are computed before they
are used. This prevents race conditions for Ops that generate gradients
for multiple inputs where the gradients depend on the inputs.

GATE\_GRAPH: Make sure all gradients for all variables are computed
before any one of them is used. This provides the least parallelism but
can be useful if you want to process all gradients before applying any
of them.

\subsubsection{Slots }\label{slots}

Some optimizer subclasses, such as \texttt{MomentumOptimizer} and
\texttt{AdagradOptimizer} allocate and manage additional variables
associated with the variables to train. These are called Slots. Slots
have names and you can ask the optimizer for the names of the slots that
it uses. Once you have a slot name you can ask the optimizer for the
variable it created to hold the slot value.

This can be useful if you want to log debug a training algorithm, report
stats about the slots, etc.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.Optimizer.get\_slot\_names()}
}{tf.train.Optimizer.get\_slot\_names() }}\label{tf.train.optimizer.getux5fslotux5fnames}

Return a list of the names of slots created by the Optimizer.

See get\_slot().

\subparagraph{Returns: }\label{returns-3}

A list of strings.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.Optimizer.get\_slot(var,\ name)}
}{tf.train.Optimizer.get\_slot(var, name) }}\label{tf.train.optimizer.getux5fslotvar-name}

Return a slot named ``name'' created for ``var'' by the Optimizer.

Some Optimizer subclasses use additional variables. For example Momentum
and Adagrad use variables to accumulate updates. This method gives
access to these Variables if for some reason you need them.

Use get\_slot\_names() to get the list of slot names created by the
Optimizer.

\subparagraph{Args: }\label{args-4}

\begin{itemize}
\tightlist
\item
  \texttt{var}: A variable passed to minimize() or apply\_gradients().
\item
  \texttt{name}: A string.
\end{itemize}

\subparagraph{Returns: }\label{returns-4}

The Variable for the slot if it was created, None otherwise.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.train.GradientDescentOptimizer}
}{class tf.train.GradientDescentOptimizer }}\label{class-tf.train.gradientdescentoptimizer}

Optimizer that implements the gradient descent algorithm.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.GradientDescentOptimizer.\_\_init\_\_(learning\_rate,\ use\_locking=False,\ name=\textquotesingle{}GradientDescent\textquotesingle{})}
}{tf.train.GradientDescentOptimizer.\_\_init\_\_(learning\_rate, use\_locking=False, name='GradientDescent') }}\label{tf.train.gradientdescentoptimizer.ux5fux5finitux5fux5flearningux5frate-useux5flockingfalse-namegradientdescent}

Construct a new gradient descent optimizer.

\subparagraph{Args: }\label{args-5}

\begin{itemize}
\tightlist
\item
  \texttt{learning\_rate}: A Tensor or a floating point value. The
  learning rate to use.
\item
  \texttt{use\_locking}: If True use locks for update operation.s
\item
  \texttt{name}: Optional name prefix for the operations created when
  applying gradients. Defaults to ``GradientDescent''.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.train.AdagradOptimizer}
}{class tf.train.AdagradOptimizer }}\label{class-tf.train.adagradoptimizer}

Optimizer that implements the Adagrad algorithm.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.AdagradOptimizer.\_\_init\_\_(learning\_rate,\ initial\_accumulator\_value=0.1,\ use\_locking=False,\ name=\textquotesingle{}Adagrad\textquotesingle{})}
}{tf.train.AdagradOptimizer.\_\_init\_\_(learning\_rate, initial\_accumulator\_value=0.1, use\_locking=False, name='Adagrad') }}\label{tf.train.adagradoptimizer.ux5fux5finitux5fux5flearningux5frate-initialux5faccumulatorux5fvalue0.1-useux5flockingfalse-nameadagrad}

Construct a new Adagrad optimizer.

\subparagraph{Args: }\label{args-6}

\begin{itemize}
\tightlist
\item
  \texttt{learning\_rate}: A \texttt{Tensor} or a floating point value.
  The learning rate.
\item
  \texttt{initial\_accumulator\_value}: A floating point value. Starting
  value for the accumulators, must be positive.
\item
  \texttt{use\_locking}: If \texttt{True} use locks for update
  operations.
\item
  \texttt{name}: Optional name prefix for the operations created when
  applying gradients. Defaults to ``Adagrad''.
\end{itemize}

\subparagraph{Raises: }\label{raises-4}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: If the initial\_accumulator\_value is invalid.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.train.MomentumOptimizer}
}{class tf.train.MomentumOptimizer }}\label{class-tf.train.momentumoptimizer}

Optimizer that implements the Momentum algorithm.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.MomentumOptimizer.\_\_init\_\_(learning\_rate,\ momentum,\ use\_locking=False,\ name=\textquotesingle{}Momentum\textquotesingle{})}
}{tf.train.MomentumOptimizer.\_\_init\_\_(learning\_rate, momentum, use\_locking=False, name='Momentum') }}\label{tf.train.momentumoptimizer.ux5fux5finitux5fux5flearningux5frate-momentum-useux5flockingfalse-namemomentum}

Construct a new Momentum optimizer.

\subparagraph{Args: }\label{args-7}

\begin{itemize}
\tightlist
\item
  \texttt{learning\_rate}: A \texttt{Tensor} or a floating point value.
  The learning rate.
\item
  \texttt{momentum}: A \texttt{Tensor} or a floating point value. The
  momentum.
\item
  \texttt{use\_locking}: If \texttt{True} use locks for update
  operations.
\item
  \texttt{name}: Optional name prefix for the operations created when
  applying gradients. Defaults to ``Momentum''.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.train.AdamOptimizer}
}{class tf.train.AdamOptimizer }}\label{class-tf.train.adamoptimizer}

Optimizer that implements the Adam algorithm.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.AdamOptimizer.\_\_init\_\_(learning\_rate=0.001,\ beta1=0.9,\ beta2=0.999,\ epsilon=1e-08,\ use\_locking=False,\ name=\textquotesingle{}Adam\textquotesingle{})}
}{tf.train.AdamOptimizer.\_\_init\_\_(learning\_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08, use\_locking=False, name='Adam') }}\label{tf.train.adamoptimizer.ux5fux5finitux5fux5flearningux5frate0.001-beta10.9-beta20.999-epsilon1e-08-useux5flockingfalse-nameadam}

Construct a new Adam optimizer.

Implementation is based on: http://arxiv.org/pdf/1412.6980v7.pdf

Initialization:

\begin{verbatim}
m_0 <- 0 (Initialize initial 1st moment vector)
v_0 <- 0 (Initialize initial 2nd moment vector)
t <- 0 (Initialize timestep)
\end{verbatim}

The update rule for \texttt{variable} with gradient \texttt{g} uses an
optimization described at the end of section2 of the paper:

\begin{verbatim}
t <- t + 1
lr_t <- learning_rate * sqrt(1 - beta2^t) / (1 - beta1^t)

m_t <- beta1 * m_{t-1} + (1 - beta1) * g
v_t <- beta2 * v_{t-1} + (1 - beta2) * g * g
variable <- variable - lr_t * m_t / (sqrt(v_t) + epsilon)
\end{verbatim}

The default value of 1e-8 for epsilon might not be a good default in
general. For example, when training an Inception network on ImageNet a
current good choice is 1.0 or 0.1.

\subparagraph{Args: }\label{args-8}

\begin{itemize}
\tightlist
\item
  \texttt{learning\_rate}: A Tensor or a floating point value. The
  learning rate.
\item
  \texttt{beta1}: A float value or a constant float tensor. The
  exponential decay rate for the 1st moment estimates.
\item
  \texttt{beta2}: A float value or a constant float tensor. The
  exponential decay rate for the 2st moment estimates.
\item
  \texttt{epsilon}: A small constant for numerical stability.
\item
  \texttt{use\_locking}: If True use locks for update operation.s
\item
  \texttt{name}: Optional name for the operations created when applying
  gradients. Defaults to ``Adam''.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.train.FtrlOptimizer}
}{class tf.train.FtrlOptimizer }}\label{class-tf.train.ftrloptimizer}

Optimizer that implements the FTRL algorithm.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.FtrlOptimizer.\_\_init\_\_(learning\_rate,\ learning\_rate\_power=-0.5,\ initial\_accumulator\_value=0.1,\ l1\_regularization\_strength=0.0,\ l2\_regularization\_strength=0.0,\ use\_locking=False,\ name=\textquotesingle{}Ftrl\textquotesingle{})}
}{tf.train.FtrlOptimizer.\_\_init\_\_(learning\_rate, learning\_rate\_power=-0.5, initial\_accumulator\_value=0.1, l1\_regularization\_strength=0.0, l2\_regularization\_strength=0.0, use\_locking=False, name='Ftrl') }}\label{tf.train.ftrloptimizer.ux5fux5finitux5fux5flearningux5frate-learningux5frateux5fpower-0.5-initialux5faccumulatorux5fvalue0.1-l1ux5fregularizationux5fstrength0.0-l2ux5fregularizationux5fstrength0.0-useux5flockingfalse-nameftrl}

Construct a new FTRL optimizer.

The Ftrl-proximal algorithm, abbreviated for
Follow-the-regularized-leader, is described in the paper
\href{https://www.eecs.tufts.edu/~dsculley/papers/ad-click-prediction.pdf}{Ad
Click Prediction: a View from the Trenches}.

It can give a good performance vs.~sparsity tradeoff.

Ftrl-proximal uses its own global base learning rate and can behave like
Adagrad with \texttt{learning\_rate\_power=-0.5}, or like gradient
descent with \texttt{learning\_rate\_power=0.0}.

The effective learning rate is adjusted per parameter, relative to this
base learning rate as:

\begin{verbatim}
effective_learning_rate_i = (learning_rate /
    pow(k + summed_squared_gradients_for_i, learning_rate_power));
\end{verbatim}

where k is the small constant \texttt{initial\_accumulator\_value}.

Note that the real regularization coefficient of
\texttt{\textbar{}w\textbar{}\^{}2} for objective function is
\texttt{1\ /\ lambda\_2} if specifying \texttt{l2\ =\ lambda\_2} as
argument when using this function.

\subparagraph{Args: }\label{args-9}

\begin{itemize}
\tightlist
\item
  \texttt{learning\_rate}: A float value or a constant float
  \texttt{Tensor}.
\item
  \texttt{learning\_rate\_power}: A float value, must be less or equal
  to zero.
\item
  \texttt{initial\_accumulator\_value}: The starting value for
  accumulators. Only positive values are allowed.
\item
  \texttt{l1\_regularization\_strength}: A float value, must be greater
  than or equal to zero.
\item
  \texttt{l2\_regularization\_strength}: A float value, must be greater
  than or equal to zero.
\item
  \texttt{use\_locking}: If \texttt{True} use locks for update
  operations.
\item
  \texttt{name}: Optional name prefix for the operations created when
  applying gradients. Defaults to ``Ftrl''.
\end{itemize}

\subparagraph{Raises: }\label{raises-5}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if one of the arguments is invalid.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.train.RMSPropOptimizer}
}{class tf.train.RMSPropOptimizer }}\label{class-tf.train.rmspropoptimizer}

Optimizer that implements the RMSProp algorithm.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.RMSPropOptimizer.\_\_init\_\_(learning\_rate,\ decay,\ momentum=0.0,\ epsilon=1e-10,\ use\_locking=False,\ name=\textquotesingle{}RMSProp\textquotesingle{})}
}{tf.train.RMSPropOptimizer.\_\_init\_\_(learning\_rate, decay, momentum=0.0, epsilon=1e-10, use\_locking=False, name='RMSProp') }}\label{tf.train.rmspropoptimizer.ux5fux5finitux5fux5flearningux5frate-decay-momentum0.0-epsilon1e-10-useux5flockingfalse-namermsprop}

Construct a new RMSProp optimizer.

\subparagraph{Args: }\label{args-10}

\begin{itemize}
\tightlist
\item
  \texttt{learning\_rate}: A Tensor or a floating point value. The
  learning rate.
\item
  \texttt{decay}: discounting factor for the history/coming gradient
\item
  \texttt{momentum}: a scalar tensor.
\item
  \texttt{epsilon}: small value to avoid zero denominator.
\item
  \texttt{use\_locking}: If True use locks for update operation.
\item
  \texttt{name}: Optional name prefic for the operations created when
  applying gradients. Defaults to ``RMSProp''.
\end{itemize}

\subsection{Gradient Computation }\label{gradient-computation}

TensorFlow provides functions to compute the derivatives for a given
TensorFlow computation graph, adding operations to the graph. The
optimizer classes automatically compute derivatives on your graph, but
creators of new Optimizers or expert users can call the lower-level
functions below.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.gradients(ys,\ xs,\ grad\_ys=None,\ name=\textquotesingle{}gradients\textquotesingle{},\ colocate\_gradients\_with\_ops=False,\ gate\_gradients=False,\ aggregation\_method=None)}
}{tf.gradients(ys, xs, grad\_ys=None, name='gradients', colocate\_gradients\_with\_ops=False, gate\_gradients=False, aggregation\_method=None) }}\label{tf.gradientsys-xs-gradux5fysnone-namegradients-colocateux5fgradientsux5fwithux5fopsfalse-gateux5fgradientsfalse-aggregationux5fmethodnone}

Constructs symbolic partial derivatives of \texttt{ys} w.r.t. x in
\texttt{xs}.

\texttt{ys} and \texttt{xs} are each a \texttt{Tensor} or a list of
tensors. \texttt{grad\_ys} is a list of \texttt{Tensor}, holding the
gradients received by the \texttt{ys}. The list must be the same length
as \texttt{ys}.

\texttt{gradients()} adds ops to the graph to output the partial
derivatives of \texttt{ys} with respect to \texttt{xs}. It returns a
list of \texttt{Tensor} of length \texttt{len(xs)} where each tensor is
the \texttt{sum(dy/dx)} for y in \texttt{ys}.

\texttt{grad\_ys} is a list of tensors of the same length as \texttt{ys}
that holds the initial gradients for each y in \texttt{ys}. When
\texttt{grad\_ys} is None, we fill in a tensor of '1's of the shape of y
for each y in \texttt{ys}. A user can provide their own initial
'grad\_ys` to compute the derivatives using a different initial gradient
for each y (e.g., if one wanted to weight the gradient differently for
each value in each y).

\subparagraph{Args: }\label{args-11}

\begin{itemize}
\tightlist
\item
  \texttt{ys}: A \texttt{Tensor} or list of tensors to be
  differentiated.
\item
  \texttt{xs}: A \texttt{Tensor} or list of tensors to be used for
  differentiation.
\item
  \texttt{grad\_ys}: Optional. A \texttt{Tensor} or list of tensors the
  same size as \texttt{ys} and holding the gradients computed for each y
  in \texttt{ys}.
\item
  \texttt{name}: Optional name to use for grouping all the gradient ops
  together. defaults to `gradients'.
\item
  \texttt{colocate\_gradients\_with\_ops}: If True, try colocating
  gradients with the corresponding op.
\item
  \texttt{gate\_gradients}: If True, add a tuple around the gradients
  returned for an operations. This avoids some race conditions.
\item
  \texttt{aggregation\_method}: Specifies the method used to combine
  gradient terms. Accepted values are constants defined in the class
  \texttt{AggregationMethod}.
\end{itemize}

\subparagraph{Returns: }\label{returns-5}

A list of \texttt{sum(dy/dx)} for each x in \texttt{xs}.

\subparagraph{Raises: }\label{raises-6}

\begin{itemize}
\tightlist
\item
  \texttt{LookupError}: if one of the operations between \texttt{x} and
  \texttt{y} does not have a registered gradient function.
\item
  \texttt{ValueError}: if the arguments are invalid.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.AggregationMethod}
}{class tf.AggregationMethod }}\label{class-tf.aggregationmethod}

A class listing aggregation methods used to combine gradients.

Computing partial derivatives can require aggregating gradient
contributions. This class lists the various methods that can be used to
combine gradients in the graph:

\begin{itemize}
\tightlist
\item
  \texttt{ADD\_N}: All of the gradient terms are summed as part of one
  operation using the ``AddN'' op. It has the property that all
  gradients must be ready before any aggregation is performed.
\item
  \texttt{DEFAULT}: The system-chosen default aggregation method.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.stop\_gradient(input,\ name=None)}
}{tf.stop\_gradient(input, name=None) }}\label{tf.stopux5fgradientinput-namenone}

Stops gradient computation.

When executed in a graph, this op outputs its input tensor as-is.

When building ops to compute gradients, this op prevents the
contribution of its inputs to be taken into account. Normally, the
gradient generator adds ops to a graph to compute the derivatives of a
specified `loss' by recursively finding out inputs that contributed to
its computation. If you insert this op in the graph it inputs are masked
from the gradient generator. They are not taken into account for
computing gradients.

This is useful any time you want to compute a value with TensorFlow but
need to pretend that the value was a constant. Some examples include:

\begin{itemize}
\tightlist
\item
  The \emph{EM} algorithm where the \emph{M-step} should not involve
  backpropagation through the output of the \emph{E-step}.
\item
  Contrastive divergence training of Boltzmann machines where, when
  differentiating the energy function, the training must not
  backpropagate through the graph that generated the samples from the
  model.
\item
  Adversarial training, where no backprop should happen through the
  adversarial example generation process.
\end{itemize}

\subparagraph{Args: }\label{args-12}

\begin{itemize}
\tightlist
\item
  \texttt{input}: A \texttt{Tensor}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-6}

A \texttt{Tensor}. Has the same type as \texttt{input}.

\subsection{Gradient Clipping }\label{gradient-clipping}

TensorFlow provides several operations that you can use to add clipping
functions to your graph. You can use these functions to perform general
data clipping, but they're particularly useful for handling exploding or
vanishing gradients.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.clip\_by\_value(t,\ clip\_value\_min,\ clip\_value\_max,\ name=None)}
}{tf.clip\_by\_value(t, clip\_value\_min, clip\_value\_max, name=None) }}\label{tf.clipux5fbyux5fvaluet-clipux5fvalueux5fmin-clipux5fvalueux5fmax-namenone}

Clips tensor values to a specified min and max.

Given a tensor \texttt{t}, this operation returns a tensor of the same
type and shape as \texttt{t} with its values clipped to
\texttt{clip\_value\_min} and \texttt{clip\_value\_max}. Any values less
than \texttt{clip\_value\_min} are set to \texttt{clip\_value\_min}. Any
values greater than \texttt{clip\_value\_max} are set to
\texttt{clip\_value\_max}.

\subparagraph{Args: }\label{args-13}

\begin{itemize}
\tightlist
\item
  \texttt{t}: A \texttt{Tensor}.
\item
  \texttt{clip\_value\_min}: A 0-D (scalar) \texttt{Tensor}. The minimum
  value to clip by.
\item
  \texttt{clip\_value\_max}: A 0-D (scalar) \texttt{Tensor}. The maximum
  value to clip by.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-7}

A clipped \texttt{Tensor}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.clip\_by\_norm(t,\ clip\_norm,\ name=None)}
}{tf.clip\_by\_norm(t, clip\_norm, name=None) }}\label{tf.clipux5fbyux5fnormt-clipux5fnorm-namenone}

Clips tensor values to a maximum L2-norm.

Given a tensor \texttt{t}, and a maximum clip value \texttt{clip\_norm},
this operation normalizes \texttt{t} so that its L2-norm is less than or
equal to
\texttt{clip\_norm\textquotesingle{}.\ Specifically,\ if\ the\ L2-norm\ is\ already\ less\ than\ or\ equal\ to}clip\_norm\texttt{,\ then}t\texttt{is\ not\ modified.\ If\ the\ L2-norm\ is\ greater\ than}clip\_norm\texttt{,\ then\ this\ operation\ returns\ a\ tensor\ of\ the\ same\ type\ and\ shape\ as}t`
with its values set to:

\texttt{t\ *\ clip\_norm\ /\ l2norm(t)}

In this case, the L2-norm of the output tensor is \texttt{clip\_norm}.

This operation is typically used to clip gradients before applying them
with an optimizer.

\subparagraph{Args: }\label{args-14}

\begin{itemize}
\tightlist
\item
  \texttt{t}: A \texttt{Tensor}.
\item
  \texttt{clip\_norm}: A 0-D (scalar) \texttt{Tensor} \textgreater{} 0.
  A maximum clipping value.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-8}

A clipped \texttt{Tensor}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.clip\_by\_average\_norm(t,\ clip\_norm,\ name=None)}
}{tf.clip\_by\_average\_norm(t, clip\_norm, name=None) }}\label{tf.clipux5fbyux5faverageux5fnormt-clipux5fnorm-namenone}

Clips tensor values to a maximum average L2-norm.

Given a tensor \texttt{t}, and a maximum clip value \texttt{clip\_norm},
this operation normalizes \texttt{t} so that its average L2-norm is less
than or equal to
\texttt{clip\_norm\textquotesingle{}.\ Specifically,\ if\ the\ average\ L2-norm\ is\ already\ less\ than\ or\ equal\ to}clip\_norm\texttt{,\ then}t\texttt{is\ not\ modified.\ If\ the\ average\ L2-norm\ is\ greater\ than}clip\_norm\texttt{,\ then\ this\ operation\ returns\ a\ tensor\ of\ the\ same\ type\ and\ shape\ as}t`
with its values set to:

\texttt{t\ *\ clip\_norm\ /\ l2norm\_avg(t)}

In this case, the average L2-norm of the output tensor is
\texttt{clip\_norm}.

This operation is typically used to clip gradients before applying them
with an optimizer.

\subparagraph{Args: }\label{args-15}

\begin{itemize}
\tightlist
\item
  \texttt{t}: A \texttt{Tensor}.
\item
  \texttt{clip\_norm}: A 0-D (scalar) \texttt{Tensor} \textgreater{} 0.
  A maximum clipping value.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-9}

A clipped \texttt{Tensor}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.clip\_by\_global\_norm(t\_list,\ clip\_norm,\ use\_norm=None,\ name=None)}
}{tf.clip\_by\_global\_norm(t\_list, clip\_norm, use\_norm=None, name=None) }}\label{tf.clipux5fbyux5fglobalux5fnormtux5flist-clipux5fnorm-useux5fnormnone-namenone}

Clips values of multiple tensors by the ratio of the sum of their norms.

Given a tuple or list of tensors \texttt{t\_list}, and a clipping ratio
\texttt{clip\_norm}, this operation returns a list of clipped tensors
\texttt{list\_clipped} and the global norm (\texttt{global\_norm}) of
all tensors in \texttt{t\_list}. Optionally, if you've already computed
the global norm for \texttt{t\_list}, you can specify the global norm
with \texttt{use\_norm}.

To perform the clipping, the values t\_list{[}i{]} are set to:

\texttt{t\_list{[}i{]}\ *\ clip\_norm\ /\ max(global\_norm,\ clip\_norm)}

where:

\texttt{global\_norm\ =\ sqrt(sum({[}l2norm(t)**2\ for\ t\ in\ t\_list{]}))}

If \texttt{clip\_norm\ \textgreater{}\ global\_norm} then the entries in
\texttt{t\_list} remain as they are, otherwise they're all shrunk by the
global ratio.

Any of the entries of \texttt{t\_list} that are of type None are
ignored.

This is the correct way to perform gradient clipping (for example, see
R. Pascanu, T. Mikolov, and Y. Bengio, ``On the difficulty of training
Recurrent Neural Networks''. http://arxiv.org/abs/1211.5063)

However, it is slower than \texttt{clip\_by\_norm()} because all the
parameters must be ready before the clipping operation can be performed.

\subparagraph{Args: }\label{args-16}

\begin{itemize}
\tightlist
\item
  \texttt{t\_list}: A tuple or list of mixed \texttt{Tensors},
  \texttt{IndexedSlices}, or None.
\item
  \texttt{clip\_norm}: A 0-D (scalar) \texttt{Tensor} \textgreater{} 0.
  The clipping ratio.
\item
  \texttt{use\_norm}: A 0-D (scalar) \texttt{Tensor} of type
  \texttt{float} (optional). The global norm to use. If not provided,
  \texttt{global\_norm()} is used to compute the norm.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-10}

\begin{itemize}
\tightlist
\item
  \texttt{list\_clipped}: A list of \texttt{Tensors} of the same type as
  \texttt{list\_t}.
\item
  \texttt{global\_norm}: A 0-D (scalar) \texttt{Tensor} representing the
  global norm.
\end{itemize}

\subparagraph{Raises: }\label{raises-7}

\begin{itemize}
\tightlist
\item
  \texttt{TypeError}: If \texttt{t\_list} is not a sequence.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.global\_norm(t\_list,\ name=None)}
}{tf.global\_norm(t\_list, name=None) }}\label{tf.globalux5fnormtux5flist-namenone}

Computes the global norm of multiple tensors.

Given a tuple or list of tensors \texttt{t\_list}, this operation
returns the global norm of the elements in all tensors in
\texttt{t\_list}. The global norm is computed as:

\texttt{global\_norm\ =\ sqrt(sum({[}l2norm(t)**2\ for\ t\ in\ t\_list{]}))}

Any entries in \texttt{t\_list} that are of type None are ignored.

\subparagraph{Args: }\label{args-17}

\begin{itemize}
\tightlist
\item
  \texttt{t\_list}: A tuple or list of mixed \texttt{Tensors},
  \texttt{IndexedSlices}, or None.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-11}

A 0-D (scalar) \texttt{Tensor} of type \texttt{float}.

\subparagraph{Raises: }\label{raises-8}

\begin{itemize}
\tightlist
\item
  \texttt{TypeError}: If \texttt{t\_list} is not a sequence.
\end{itemize}

\subsection{Decaying the learning rate
}\label{decaying-the-learning-rate}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.exponential\_decay(learning\_rate,\ global\_step,\ decay\_steps,\ decay\_rate,\ staircase=False,\ name=None)}
}{tf.train.exponential\_decay(learning\_rate, global\_step, decay\_steps, decay\_rate, staircase=False, name=None) }}\label{tf.train.exponentialux5fdecaylearningux5frate-globalux5fstep-decayux5fsteps-decayux5frate-staircasefalse-namenone}

Applies exponential decay to the learning rate.

When training a model, it is often recommended to lower the learning
rate as the training progresses. This function applies an exponential
decay function to a provided initial learning rate. It requires a
\texttt{global\_step} value to compute the decayed learning rate. You
can just pass a TensorFlow variable that you increment at each training
step.

The function returns the decayed learning rate. It is computed as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{decayed_learning_rate }\OperatorTok{=} \NormalTok{learning_rate }\OperatorTok{*}
                        \NormalTok{decay_rate }\OperatorTok{^} \NormalTok{(global_step }\OperatorTok{/} \NormalTok{decay_steps)}
\end{Highlighting}
\end{Shaded}

If the argument \texttt{staircase} is \texttt{True}, then
\texttt{global\_step\ /decay\_steps} is an integer division and the
decayed learning rate follows a staircase function.

Example: decay every 100000 steps with a base of 0.96:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...}
\NormalTok{global_step }\OperatorTok{=} \NormalTok{tf.Variable(}\DecValTok{0}\NormalTok{, trainable}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\NormalTok{starter_learning_rate }\OperatorTok{=} \FloatTok{0.1}
\NormalTok{learning_rate }\OperatorTok{=} \NormalTok{tf.exponential_decay(starter_learning_rate, global_step,}
                                     \DecValTok{100000}\NormalTok{, }\FloatTok{0.96}\NormalTok{, staircase}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\NormalTok{optimizer }\OperatorTok{=} \NormalTok{tf.GradientDescent(learning_rate)}
\CommentTok{# Passing global_step to minimize() will increment it at each step.}
\NormalTok{optimizer.minimize(...my loss..., global_step}\OperatorTok{=}\NormalTok{global_step)}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-18}

\begin{itemize}
\tightlist
\item
  \texttt{learning\_rate}: A scalar \texttt{float32} or \texttt{float64}
  \texttt{Tensor} or a Python number. The initial learning rate.
\item
  \texttt{global\_step}: A scalar \texttt{int32} or \texttt{int64}
  \texttt{Tensor} or a Python number. Global step to use for the decay
  computation. Must not be negative.
\item
  \texttt{decay\_steps}: A scalar \texttt{int32} or \texttt{int64}
  \texttt{Tensor} or a Python number. Must be positive. See the decay
  computation above.
\item
  \texttt{decay\_rate}: A scalar \texttt{float32} or \texttt{float64}
  \texttt{Tensor} or a Python number. The decay rate.
\item
  \texttt{staircase}: Boolean. It \texttt{True} decay the learning rate
  at discrete intervals.
\item
  \texttt{name}: string. Optional name of the operation. Defaults to
  `ExponentialDecay'
\end{itemize}

\subparagraph{Returns: }\label{returns-12}

A scalar \texttt{Tensor} of the same type as \texttt{learning\_rate}.
The decayed learning rate.

\subsection{Moving Averages }\label{moving-averages}

Some training algorithms, such as GradientDescent and Momentum often
benefit from maintaining a moving average of variables during
optimization. Using the moving averages for evaluations often improve
results significantly.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.train.ExponentialMovingAverage}
}{class tf.train.ExponentialMovingAverage }}\label{class-tf.train.exponentialmovingaverage}

Maintains moving averages of variables by employing and exponential
decay.

When training a model, it is often beneficial to maintain moving
averages of the trained parameters. Evaluations that use averaged
parameters sometimes produce significantly better results than the final
trained values.

The \texttt{apply()} method adds shadow copies of trained variables and
add ops that maintain a moving average of the trained variables in their
shadow copies. It is used when building the training model. The ops that
maintain moving averages are typically run after each training step. The
\texttt{average()} and \texttt{average\_name()} methods give access to
the shadow variables and their names. They are useful when building an
evaluation model, or when restoring a model from a checkpoint file. They
help use the moving averages in place of the last trained values for
evaluations.

The moving averages are computed using exponential decay. You specify
the decay value when creating the \texttt{ExponentialMovingAverage}
object. The shadow variables are initialized with the same initial
values as the trained variables. When you run the ops to maintain the
moving averages, each shadow variable is updated with the formula:

\texttt{shadow\_variable\ -=\ (1\ -\ decay)\ *\ (shadow\_variable\ -\ variable)}

This is mathematically equivalent to the classic formula below, but the
use of an \texttt{assign\_sub} op (the \texttt{"-="} in the formula)
allows concurrent lockless updates to the variables:

\texttt{shadow\_variable\ =\ decay\ *\ shadow\_variable\ +\ (1\ -\ decay)\ *\ variable}

Reasonable values for \texttt{decay} are close to 1.0, typically in the
multiple-nines range: 0.999, 0.9999, etc.

Example usage when creating a training model:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create variables.}
\NormalTok{var0 }\OperatorTok{=} \NormalTok{tf.Variable(...)}
\NormalTok{var1 }\OperatorTok{=} \NormalTok{tf.Variable(...)}
\CommentTok{# ... use the variables to build a training model...}
\NormalTok{...}
\CommentTok{# Create an op that applies the optimizer.  This is what we usually}
\CommentTok{# would use as a training op.}
\NormalTok{opt_op }\OperatorTok{=} \NormalTok{opt.minimize(my_loss, [var0, var1])}

\CommentTok{# Create an ExponentialMovingAverage object}
\NormalTok{ema }\OperatorTok{=} \NormalTok{tf.train.ExponentialMovingAverage(decay}\OperatorTok{=}\FloatTok{0.9999}\NormalTok{)}

\CommentTok{# Create the shadow variables, and add ops to maintain moving averages}
\CommentTok{# of var0 and var1.}
\NormalTok{maintain_averages_op }\OperatorTok{=} \NormalTok{ema.}\BuiltInTok{apply}\NormalTok{([var0, var1])}

\CommentTok{# Create an op that will update the moving averages after each training}
\CommentTok{# step.  This is what we will use in place of the usuall trainig op.}
\ControlFlowTok{with} \NormalTok{tf.control_dependencies([opt_op]):}
    \NormalTok{training_op }\OperatorTok{=} \NormalTok{tf.group(maintain_averages_op)}

\NormalTok{...train the model by running training_op...}
\end{Highlighting}
\end{Shaded}

There are two ways to use the moving averages for evaluations:

\begin{itemize}
\tightlist
\item
  Build a model that uses the shadow variables instead of the variables.
  For this, use the \texttt{average()} method which returns the shadow
  variable for a given variable.
\item
  Build a model normally but load the checkpoint files to evaluate by
  using the shadow variable names. For this use the
  \texttt{average\_name()} method. See the
  \href{../../api_docs/python/train.md\#Saver}{Saver class} for more
  information on restoring saved variables.
\end{itemize}

Example of restoring the shadow variable values:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a Saver that loads variables from their saved shadow values.}
\NormalTok{shadow_var0_name }\OperatorTok{=} \NormalTok{ema.average_name(var0)}
\NormalTok{shadow_var1_name }\OperatorTok{=} \NormalTok{ema.average_name(var1)}
\NormalTok{saver }\OperatorTok{=} \NormalTok{tf.train.Saver(\{shadow_var0_name: var0, shadow_var1_name: var1\})}
\NormalTok{saver.restore(...checkpoint filename...)}
\CommentTok{# var0 and var1 now hold the moving average values}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.ExponentialMovingAverage.\_\_init\_\_(decay,\ num\_updates=None,\ name=\textquotesingle{}ExponentialMovingAverage\textquotesingle{})}
}{tf.train.ExponentialMovingAverage.\_\_init\_\_(decay, num\_updates=None, name='ExponentialMovingAverage') }}\label{tf.train.exponentialmovingaverage.ux5fux5finitux5fux5fdecay-numux5fupdatesnone-nameexponentialmovingaverage}

Creates a new ExponentialMovingAverage object.

The \texttt{Apply()} method has to be called to create shadow variables
and add ops to maintain moving averages.

The optional \texttt{num\_updates} parameter allows one to tweak the
decay rate dynamically. . It is typical to pass the count of training
steps, usually kept in a variable that is incremented at each step, in
which case the decay rate is lower at the start of training. This makes
moving averages move faster. If passed, the actual decay rate used is:

\texttt{min(decay,\ (1\ +\ num\_updates)\ /\ (10\ +\ num\_updates))}

\subparagraph{Args: }\label{args-19}

\begin{itemize}
\tightlist
\item
  \texttt{decay}: Float. The decay to use.
\item
  \texttt{num\_updates}: Optional count of number of updates applied to
  variables.
\item
  \texttt{name}: String. Optional prefix name to use for the name of ops
  added in \texttt{Apply()}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.ExponentialMovingAverage.apply(var\_list=None)}
}{tf.train.ExponentialMovingAverage.apply(var\_list=None) }}\label{tf.train.exponentialmovingaverage.applyvarux5flistnone}

Maintains moving averages of variables.

\texttt{var\_list} must be a list of \texttt{Variable} or
\texttt{Tensor} objects. This method creates shadow variables for all
elements of \texttt{var\_list}. Shadow variables for \texttt{Variable}
objects are initialized to the variable's initial value. For
\texttt{Tensor} objects, the shadow variables are initialized to 0.

shadow variables are created with \texttt{trainable=False} and added to
the \texttt{GraphKeys.ALL\_VARIABLES} collection. They will be returned
by calls to \texttt{tf.all\_variables()}.

Returns an op that updates all shadow variables as described above.

Note that \texttt{apply()} can be called multiple times with different
lists of variables.

\subparagraph{Args: }\label{args-20}

\begin{itemize}
\tightlist
\item
  \texttt{var\_list}: A list of Variable or Tensor objects. The
  variables and Tensors must be of types float32 or float64.
\end{itemize}

\subparagraph{Returns: }\label{returns-13}

An Operation that updates the moving averages.

\subparagraph{Raises: }\label{raises-9}

\begin{itemize}
\tightlist
\item
  \texttt{TypeError}: If the arguments are not all float32 or float64.
\item
  \texttt{ValueError}: If the moving average of one of the variables is
  already being computed.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.ExponentialMovingAverage.average\_name(var)}
}{tf.train.ExponentialMovingAverage.average\_name(var) }}\label{tf.train.exponentialmovingaverage.averageux5fnamevar}

Returns the name of the \texttt{Variable} holding the average for
\texttt{var}.

The typical scenario for \texttt{ExponentialMovingAverage} is to compute
moving averages of variables during training, and restore the variables
from the computed moving averages during evaluations.

To restore variables, you have to know the name of the shadow variables.
That name and the original variable can then be passed to a
\texttt{Saver()} object to restore the variable from the moving average
value with:
\texttt{saver\ =\ tf.train.Saver(\{ema.average\_name(var):\ var\})}

\texttt{average\_name()} can be called whether or not \texttt{apply()}
has been called.

\subparagraph{Args: }\label{args-21}

\begin{itemize}
\tightlist
\item
  \texttt{var}: A \texttt{Variable} object.
\end{itemize}

\subparagraph{Returns: }\label{returns-14}

A string: the name of the variable that will be used or was used by the
\texttt{ExponentialMovingAverage\ class} to hold the moving average of
\texttt{var}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.ExponentialMovingAverage.average(var)}
}{tf.train.ExponentialMovingAverage.average(var) }}\label{tf.train.exponentialmovingaverage.averagevar}

Returns the \texttt{Variable} holding the average of \texttt{var}.

\subparagraph{Args: }\label{args-22}

\begin{itemize}
\tightlist
\item
  \texttt{var}: A \texttt{Variable} object.
\end{itemize}

\subparagraph{Returns: }\label{returns-15}

A \texttt{Variable} object or \texttt{None} if the moving average of
\texttt{var} is not maintained..

\subsection{Coordinator and QueueRunner
}\label{coordinator-and-queuerunner}

See \href{../../how_tos/threading_and_queues/index.md}{Threading and
Queues} for how to use threads and queues. For documentation on the
Queue API, see \href{../../api_docs/python/io_ops.md\#queues}{Queues}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.train.Coordinator}
}{class tf.train.Coordinator }}\label{class-tf.train.coordinator}

A coordinator for threads.

This class implements a simple mechanism to coordinate the termination
of a set of threads.

\paragraph{Usage: }\label{usage-1}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a coordinator.}
\NormalTok{coord }\OperatorTok{=} \NormalTok{Coordinator()}
\CommentTok{# Start a number of threads, passing the coordinator to each of them.}
\NormalTok{...start thread }\DecValTok{1}\NormalTok{...(coord, ...)}
\NormalTok{...start thread N...(coord, ...)}
\CommentTok{# Wait for all the threads to terminate.}
\NormalTok{coord.join(threads)}
\end{Highlighting}
\end{Shaded}

Any of the threads can call \texttt{coord.request\_stop()} to ask for
all the threads to stop. To cooperate with the requests, each thread
must check for \texttt{coord.should\_stop()} on a regular basis.
\texttt{coord.should\_stop()} returns \texttt{True} as soon as
\texttt{coord.request\_stop()} has been called.

A typical thread running with a Coordinator will do something like:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{not} \NormalTok{coord.should_stop():}
   \NormalTok{...do some work...}
\end{Highlighting}
\end{Shaded}

\paragraph{Exception handling: }\label{exception-handling}

A thread can report an exception to the Coordinator as part of the
\texttt{should\_stop()} call. The exception will be re-raised from the
\texttt{coord.join()} call.

Thread code:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
  \ControlFlowTok{while} \OperatorTok{not} \NormalTok{coord.should_stop():}
    \NormalTok{...do some work...}
\ControlFlowTok{except} \PreprocessorTok{Exception}\NormalTok{, e:}
  \NormalTok{coord.request_stop(e)}
\end{Highlighting}
\end{Shaded}

Main code:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
  \NormalTok{...}
  \NormalTok{coord }\OperatorTok{=} \NormalTok{Coordinator()}
  \CommentTok{# Start a number of threads, passing the coordinator to each of them.}
  \NormalTok{...start thread }\DecValTok{1}\NormalTok{...(coord, ...)}
  \NormalTok{...start thread N...(coord, ...)}
  \CommentTok{# Wait for all the threads to terminate.}
  \NormalTok{coord.join(threads)}
\ControlFlowTok{except} \PreprocessorTok{Exception}\NormalTok{, e:}
  \NormalTok{...exception that was passed to coord.request_stop()}
\end{Highlighting}
\end{Shaded}

\paragraph{Grace period for stopping: }\label{grace-period-for-stopping}

After a thread has called \texttt{coord.request\_stop()} the other
threads have a fixed time to stop, this is called the `stop grace
period' and defaults to 2 minutes. If any of the threads is still alive
after the grace period expires \texttt{coord.join()} raises a
RuntimeException reporting the laggards.

\begin{verbatim}
try:
  ...
  coord = Coordinator()
  # Start a number of threads, passing the coordinator to each of them.
  ...start thread 1...(coord, ...)
  ...start thread N...(coord, ...)
  # Wait for all the threads to terminate, give them 10s grace period
  coord.join(threads, stop_grace_period_secs=10)
except RuntimeException:
  ...one of the threads took more than 10s to stop after request_stop()
  ...was called.
except Exception:
  ...exception that was passed to coord.request_stop()
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.Coordinator.\_\_init\_\_()}
}{tf.train.Coordinator.\_\_init\_\_() }}\label{tf.train.coordinator.ux5fux5finitux5fux5f}

Create a new Coordinator.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.Coordinator.join(threads,\ stop\_grace\_period\_secs=120)}
}{tf.train.Coordinator.join(threads, stop\_grace\_period\_secs=120) }}\label{tf.train.coordinator.jointhreads-stopux5fgraceux5fperiodux5fsecs120}

Wait for threads to terminate.

Blocks until all `threads' have terminated or request\_stop() is called.

After the threads stop, if an `exc\_info' was passed to request\_stop,
that exception is re-reaised.

Grace period handling: When request\_stop() is called, threads are given
`stop\_grace\_period\_secs' seconds to terminate. If any of them is
still alive after that period expires, a RuntimeError is raised. Note
that if an `exc\_info' was passed to request\_stop() then it is raised
instead of that RuntimeError.

\subparagraph{Args: }\label{args-23}

\begin{itemize}
\tightlist
\item
  \texttt{threads}: List threading.Threads. The started threads to join.
\item
  \texttt{stop\_grace\_period\_secs}: Number of seconds given to threads
  to stop after request\_stop() has been called.
\end{itemize}

\subparagraph{Raises: }\label{raises-10}

\begin{itemize}
\tightlist
\item
  \texttt{RuntimeError}: If any thread is still alive after
  request\_stop() is called and the grace period expires.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.Coordinator.request\_stop(ex=None)}
}{tf.train.Coordinator.request\_stop(ex=None) }}\label{tf.train.coordinator.requestux5fstopexnone}

Request that the threads stop.

After this is called, calls to should\_stop() will return True.

\subparagraph{Args: }\label{args-24}

\begin{itemize}
\tightlist
\item
  \texttt{ex}: Optional Exception, or Python `exc\_info' tuple as
  returned by sys.exc\_info(). If this is the first call to
  request\_stop() the corresponding exception is recorded and re-raised
  from join().
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.Coordinator.should\_stop()}
}{tf.train.Coordinator.should\_stop() }}\label{tf.train.coordinator.shouldux5fstop}

Check if stop was requested.

\subparagraph{Returns: }\label{returns-16}

True if a stop was requested.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.Coordinator.wait\_for\_stop(timeout=None)}
}{tf.train.Coordinator.wait\_for\_stop(timeout=None) }}\label{tf.train.coordinator.waitux5fforux5fstoptimeoutnone}

Wait till the Coordinator is told to stop.

\subparagraph{Args: }\label{args-25}

\begin{itemize}
\tightlist
\item
  \texttt{timeout}: float. Sleep for up to that many seconds waiting for
  should\_stop() to become True.
\end{itemize}

\subparagraph{Returns: }\label{returns-17}

True if the Coordinator is told stop, False if the timeout expired.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.train.QueueRunner}
}{class tf.train.QueueRunner }}\label{class-tf.train.queuerunner}

Holds a list of enqueue operations for a queue, each to be run in a
thread.

Queues are a convenient TensorFlow mechanism to compute tensors
asynchronously using multiple threads. For example in the canonical
`Input Reader' setup one set of threads generates filenames in a queue;
a second set of threads read records from the files, processes them, and
enqueues tensors on a second queue; a third set of threads dequeues
these input records to construct batches and runs them through training
operations.

There are several delicate issues when running multiple threads that
way: closing the queues in sequence as the input is exhausted, correctly
catching and reporting exceptions, etc.

The \texttt{QueueRunner}, combined with the \texttt{Coordinator}, helps
handle these issues. - - -

\paragraph{\texorpdfstring{\texttt{tf.train.QueueRunner.\_\_init\_\_(queue,\ enqueue\_ops)}
}{tf.train.QueueRunner.\_\_init\_\_(queue, enqueue\_ops) }}\label{tf.train.queuerunner.ux5fux5finitux5fux5fqueue-enqueueux5fops}

Create a QueueRunner.

On construction the \texttt{QueueRunner} adds an op to close the queue.
That op will be run if the enqueue ops raise exceptions.

When you later call the \texttt{create\_threads()} method, the
\texttt{QueueRunner} will create one thread for each op in
\texttt{enqueue\_ops}. Each thread will run its enqueue op in parallel
with the other threads. The enqueue ops do not have to all be the same
op, but it is expected that they all enqueue tensors in \texttt{queue}.

\subparagraph{Args: }\label{args-26}

\begin{itemize}
\tightlist
\item
  \texttt{queue}: A \texttt{Queue}.
\item
  \texttt{enqueue\_ops}: List of enqueue ops to run in threads later.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.QueueRunner.create\_threads(sess,\ coord=None,\ daemon=False,\ start=False)}
}{tf.train.QueueRunner.create\_threads(sess, coord=None, daemon=False, start=False) }}\label{tf.train.queuerunner.createux5fthreadssess-coordnone-daemonfalse-startfalse}

Create threads to run the enqueue ops.

This method requires a session in which the graph was launched. It
creates a list of threads, optionally starting them. There is one thread
for each op passed in \texttt{enqueue\_ops}.

The \texttt{coord} argument is an optional coordinator, that the threads
will use to terminate together and report exceptions. If a coordinator
is given, this method starts an additional thread to close the queue
when the coordinator requests a stop.

This method may be called again as long as all threads from a previous
call have stopped.

\subparagraph{Args: }\label{args-27}

\begin{itemize}
\tightlist
\item
  \texttt{sess}: A \texttt{Session}.
\item
  \texttt{coord}: Optional \texttt{Coordinator} object for reporting
  errors and checking stop conditions.
\item
  \texttt{daemon}: Boolean. If \texttt{True} make the threads daemon
  threads.
\item
  \texttt{start}: Boolean. If \texttt{True} starts the threads. If
  \texttt{False} the caller must call the \texttt{start()} method of the
  returned threads.
\end{itemize}

\subparagraph{Returns: }\label{returns-18}

A list of threads.

\subparagraph{Raises: }\label{raises-11}

\begin{itemize}
\tightlist
\item
  \texttt{RuntimeError}: If threads from a previous call to
  \texttt{create\_threads()} are still running.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.QueueRunner.exceptions\_raised}
}{tf.train.QueueRunner.exceptions\_raised }}\label{tf.train.queuerunner.exceptionsux5fraised}

Exceptions raised but not handled by the \texttt{QueueRunner} threads.

Exceptions raised in queue runner threads are handled in one of two ways
depending on whether or not a \texttt{Coordinator} was passed to
\texttt{create\_threads()}:

\begin{itemize}
\tightlist
\item
  With a \texttt{Coordinator}, exceptions are reported to the
  coordinator and forgotten by the \texttt{QueueRunner}.
\item
  Without a \texttt{Coordinator}, exceptions are captured by the
  \texttt{QueueRunner} and made available in this
  \texttt{exceptions\_raised} property.
\end{itemize}

\subparagraph{Returns: }\label{returns-19}

A list of Python \texttt{Exception} objects. The list is empty if no
exception was captured. (No exceptions are captured when using a
Coordinator.)

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.add\_queue\_runner(qr,\ collection=\textquotesingle{}queue\_runners\textquotesingle{})}
}{tf.train.add\_queue\_runner(qr, collection='queue\_runners') }}\label{tf.train.addux5fqueueux5frunnerqr-collectionqueueux5frunners}

Adds a \texttt{QueueRunner} to a collection in the graph.

When building a complex model that uses many queues it is often
difficult to gather all the queue runners that need to be run. This
convenience function allows you to add a queue runner to a well known
collection in the graph.

The companion method \texttt{start\_queue\_runners()} can be used to
start threads for all the collected queue runners.

\subparagraph{Args: }\label{args-28}

\begin{itemize}
\tightlist
\item
  \texttt{qr}: A \texttt{QueueRunner}.
\item
  \texttt{collection}: A \texttt{GraphKey} specifying the graph
  collection to add the queue runner to. Defaults to
  \texttt{GraphKeys.QUEUE\_RUNNERS}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.start\_queue\_runners(sess=None,\ coord=None,\ daemon=True,\ start=True,\ collection=\textquotesingle{}queue\_runners\textquotesingle{})}
}{tf.train.start\_queue\_runners(sess=None, coord=None, daemon=True, start=True, collection='queue\_runners') }}\label{tf.train.startux5fqueueux5frunnerssessnone-coordnone-daemontrue-starttrue-collectionqueueux5frunners}

Starts all queue runners collected in the graph.

This is a companion method to \texttt{add\_queue\_runner()}. It just
starts threads for all queue runners collected in the graph. It returns
the list of all threads.

\subparagraph{Args: }\label{args-29}

\begin{itemize}
\tightlist
\item
  \texttt{sess}: \texttt{Session} used to run the queue ops. Defaults to
  the default session.
\item
  \texttt{coord}: Optional \texttt{Coordinator} for coordinating the
  started threads.
\item
  \texttt{daemon}: Whether the threads should be marked as
  \texttt{daemons}, meaning they don't block program exit.
\item
  \texttt{start}: Set to \texttt{False} to only create the threads, not
  start them.
\item
  \texttt{collection}: A \texttt{GraphKey} specifying the graph
  collection to get the queue runners from. Defaults to
  \texttt{GraphKeys.QUEUE\_RUNNERS}.
\end{itemize}

\subparagraph{Returns: }\label{returns-20}

A list of threads.

\subsection{Summary Operations }\label{summary-operations}

The following ops output
\href{https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/summary.proto}{\texttt{Summary}}
protocol buffers as serialized string tensors.

You can fetch the output of a summary op in a session, and pass it to a
\href{../../api_docs/python/train.md\#SummaryWriter}{SummaryWriter} to
append it to an event file. Event files contain
\href{https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/util/event.proto}{\texttt{Event}}
protos that can contain \texttt{Summary} protos along with the timestamp
and step. You can then use TensorBoard to visualize the contents of the
event files. See
\href{../../how_tos/summaries_and_tensorboard/index.md}{TensorBoard and
Summaries} for more details.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.scalar\_summary(tags,\ values,\ collections=None,\ name=None)}
}{tf.scalar\_summary(tags, values, collections=None, name=None) }}\label{tf.scalarux5fsummarytags-values-collectionsnone-namenone}

Outputs a \texttt{Summary} protocol buffer with scalar values.

The input \texttt{tags} and \texttt{values} must have the same shape.
The generated summary has a summary value for each tag-value pair in
\texttt{tags} and \texttt{values}.

\subparagraph{Args: }\label{args-30}

\begin{itemize}
\tightlist
\item
  \texttt{tags}: A 1-D \texttt{string} \texttt{Tensor}. Tags for the
  summaries.
\item
  \texttt{values}: A 1-D \texttt{float32} or \texttt{float64} Tensor.
  Values for the summaries.
\item
  \texttt{collections}: Optional list of graph collections keys. The new
  summary op is added to these collections. Defaults to
  \texttt{{[}GraphKeys.SUMMARIES{]}}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-21}

A scalar \texttt{Tensor} of type \texttt{string}. The serialized
\texttt{Summary} protocol buffer.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image\_summary(tag,\ tensor,\ max\_images=None,\ collections=None,\ name=None)}
}{tf.image\_summary(tag, tensor, max\_images=None, collections=None, name=None) }}\label{tf.imageux5fsummarytag-tensor-maxux5fimagesnone-collectionsnone-namenone}

Outputs a \texttt{Summary} protocol buffer with images.

The summary has up to \texttt{max\_images} summary values containing
images. The images are built from \texttt{tensor} which must be 4-D with
shape \texttt{{[}batch\_size,\ height,\ width,\ channels{]}} and where
\texttt{channels} can be:

\begin{itemize}
\tightlist
\item
  1: \texttt{tensor} is interpreted as Grayscale.
\item
  3: \texttt{tensor} is interpreted as RGB.
\item
  4: \texttt{tensor} is interpreted as RGBA.
\end{itemize}

The images have the same number of channels as the input tensor. Their
values are normalized, one image at a time, to fit in the range
\texttt{{[}0,\ 255{]}}. The op uses two different normalization
algorithms:

\begin{itemize}
\item
  If the input values are all positive, they are rescaled so the largest
  one is 255.
\item
  If any input value is negative, the values are shifted so input value
  0.0 is at 127. They are then rescaled so that either the smallest
  value is 0, or the largest one is 255.
\end{itemize}

The \texttt{tag} argument is a scalar \texttt{Tensor} of type
\texttt{string}. It is used to build the \texttt{tag} of the summary
values:

\begin{itemize}
\tightlist
\item
  If \texttt{max\_images} is 1, the summary value tag is
  `\emph{tag}/image'.
\item
  If \texttt{max\_images} is greater than 1, the summary value tags are
  generated sequentially as `\emph{tag}/image/0', `\emph{tag}/image/1',
  etc.
\end{itemize}

\subparagraph{Args: }\label{args-31}

\begin{itemize}
\tightlist
\item
  \texttt{tag}: A scalar \texttt{Tensor} of type \texttt{string}. Used
  to build the \texttt{tag} of the summary values.
\item
  \texttt{tensor}: A 4-D \texttt{float32} \texttt{Tensor} of shape
  \texttt{{[}batch\_size,\ height,\ width,\ \ \ \ channels{]}} where
  \texttt{channels} is 1, 3, or 4.
\item
  \texttt{max\_images}: Max number of batch elements to generate images
  for.
\item
  \texttt{collections}: Optional list of ops.GraphKeys. The collections
  to add the summary to. Defaults to {[}ops.GraphKeys.SUMMARIES{]}
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-22}

A scalar \texttt{Tensor} of type \texttt{string}. The serialized
\texttt{Summary} protocol buffer.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.histogram\_summary(tag,\ values,\ collections=None,\ name=None)}
}{tf.histogram\_summary(tag, values, collections=None, name=None) }}\label{tf.histogramux5fsummarytag-values-collectionsnone-namenone}

Outputs a \texttt{Summary} protocol buffer with a histogram.

The generated
\href{https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/summary.proto}{\texttt{Summary}}
has one summary value containing a histogram for \texttt{values}.

This op reports an \texttt{OutOfRange} error if any value is not finite.

\subparagraph{Args: }\label{args-32}

\begin{itemize}
\tightlist
\item
  \texttt{tag}: A \texttt{string} \texttt{Tensor}. 0-D. Tag to use for
  the summary value.
\item
  \texttt{values}: A \texttt{float32} \texttt{Tensor}. Any shape. Values
  to use to build the histogram.
\item
  \texttt{collections}: Optional list of graph collections keys. The new
  summary op is added to these collections. Defaults to
  \texttt{{[}GraphKeys.SUMMARIES{]}}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-23}

A scalar \texttt{Tensor} of type \texttt{string}. The serialized
\texttt{Summary} protocol buffer.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.zero\_fraction(value,\ name=None)}
}{tf.nn.zero\_fraction(value, name=None) }}\label{tf.nn.zeroux5ffractionvalue-namenone}

Returns the fraction of zeros in \texttt{value}.

If \texttt{value} is empty, the result is \texttt{nan}.

This is useful in summaries to measure and report sparsity. For example,

\begin{verbatim}
z = tf.Relu(...)
summ = tf.scalar_summary('sparsity', tf.zero_fraction(z))
\end{verbatim}

\subparagraph{Args: }\label{args-33}

\begin{itemize}
\tightlist
\item
  \texttt{value}: A tensor of numeric type.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-24}

The fraction of zeros in \texttt{value}, with type \texttt{float32}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.merge\_summary(inputs,\ collections=None,\ name=None)}
}{tf.merge\_summary(inputs, collections=None, name=None) }}\label{tf.mergeux5fsummaryinputs-collectionsnone-namenone}

Merges summaries.

This op creates a
\href{https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/summary.proto}{\texttt{Summary}}
protocol buffer that contains the union of all the values in the input
summaries.

When the Op is run, it reports an \texttt{InvalidArgument} error if
multiple values in the summaries to merge use the same tag.

\subparagraph{Args: }\label{args-34}

\begin{itemize}
\tightlist
\item
  \texttt{inputs}: A list of \texttt{string} \texttt{Tensor} objects
  containing serialized \texttt{Summary} protocol buffers.
\item
  \texttt{collections}: Optional list of graph collections keys. The new
  summary op is added to these collections. Defaults to
  \texttt{{[}GraphKeys.SUMMARIES{]}}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-25}

A scalar \texttt{Tensor} of type \texttt{string}. The serialized
\texttt{Summary} protocol buffer resulting from the merging.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.merge\_all\_summaries(key=\textquotesingle{}summaries\textquotesingle{})}
}{tf.merge\_all\_summaries(key='summaries') }}\label{tf.mergeux5fallux5fsummarieskeysummaries}

Merges all summaries collected in the default graph.

\subparagraph{Args: }\label{args-35}

\begin{itemize}
\tightlist
\item
  \texttt{key}: \texttt{GraphKey} used to collect the summaries.
  Defaults to \texttt{GraphKeys.SUMMARIES}.
\end{itemize}

\subparagraph{Returns: }\label{returns-26}

If no summaries were collected, returns None. Otherwise returns a scalar
\texttt{Tensor} of type\texttt{string} containing the serialized
\texttt{Summary} protocol buffer resulting from the merging.

\subsection{Adding Summaries to Event Files
}\label{adding-summaries-to-event-files}

See \href{../../how_tos/summaries_and_tensorboard/index.md}{Summaries
and TensorBoard} for an overview of summaries, event files, and
visualization in TensorBoard.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.train.SummaryWriter}
}{class tf.train.SummaryWriter }}\label{class-tf.train.summarywriter}

Writes \texttt{Summary} protocol buffers to event files.

The \texttt{SummaryWriter} class provides a mechanism to create an event
file in a given directory and add summaries and events to it. The class
updates the file contents asynchronously. This allows a training program
to call methods to add data to the file directly from the training loop,
without slowing down training.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.SummaryWriter.\_\_init\_\_(logdir,\ graph\_def=None,\ max\_queue=10,\ flush\_secs=120)}
}{tf.train.SummaryWriter.\_\_init\_\_(logdir, graph\_def=None, max\_queue=10, flush\_secs=120) }}\label{tf.train.summarywriter.ux5fux5finitux5fux5flogdir-graphux5fdefnone-maxux5fqueue10-flushux5fsecs120}

Creates a \texttt{SummaryWriter} and an event file.

On construction the summary writer creates a new event file in
\texttt{logdir}. This event file will contain \texttt{Event} protocol
buffers constructed when you call one of the following functions:
\texttt{add\_summary()}, \texttt{add\_event()}, or
\texttt{add\_graph()}.

If you pass a \texttt{graph\_def} protocol buffer to the constructor it
is added to the event file. (This is equivalent to calling
\texttt{add\_graph()} later).

TensorBoard will pick the graph from the file and display it graphically
so you can interactively explore the graph you built. You will usually
pass the graph from the session in which you launched it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...create a graph...}
\CommentTok{# Launch the graph in a session.}
\NormalTok{sess }\OperatorTok{=} \NormalTok{tf.Session()}
\CommentTok{# Create a summary writer, add the 'graph_def' to the event file.}
\NormalTok{writer }\OperatorTok{=} \NormalTok{tf.train.SummaryWriter(}\OperatorTok{<}\NormalTok{some}\OperatorTok{-}\NormalTok{directory}\OperatorTok{>}\NormalTok{, sess.graph_def)}
\end{Highlighting}
\end{Shaded}

The other arguments to the constructor control the asynchronous writes
to the event file:

\begin{itemize}
\tightlist
\item
  \texttt{flush\_secs}: How often, in seconds, to flush the added
  summaries and events to disk.
\item
  \texttt{max\_queue}: Maximum number of summaries or events pending to
  be written to disk before one of the `add' calls block.
\end{itemize}

\subparagraph{Args: }\label{args-36}

\begin{itemize}
\tightlist
\item
  \texttt{logdir}: A string. Directory where event file will be written.
\item
  \texttt{graph\_def}: A \texttt{GraphDef} protocol buffer.
\item
  \texttt{max\_queue}: Integer. Size of the queue for pending events and
  summaries.
\item
  \texttt{flush\_secs}: Number. How often, in seconds, to flush the
  pending events and summaries to disk.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.SummaryWriter.add\_summary(summary,\ global\_step=None)}
}{tf.train.SummaryWriter.add\_summary(summary, global\_step=None) }}\label{tf.train.summarywriter.addux5fsummarysummary-globalux5fstepnone}

Adds a \texttt{Summary} protocol buffer to the event file.

This method wraps the provided summary in an \texttt{Event} procotol
buffer and adds it to the event file.

You can pass the output of any summary op, as-is, to this function. You
can also pass a \texttt{Summary} procotol buffer that you manufacture
with your own data. This is commonly done to report evaluation results
in event files.

\subparagraph{Args: }\label{args-37}

\begin{itemize}
\tightlist
\item
  \texttt{summary}: A \texttt{Summary} protocol buffer, optionally
  serialized as a string.
\item
  \texttt{global\_step}: Number. Optional global step value to record
  with the summary.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.SummaryWriter.add\_event(event)}
}{tf.train.SummaryWriter.add\_event(event) }}\label{tf.train.summarywriter.addux5feventevent}

Adds an event to the event file.

\subparagraph{Args: }\label{args-38}

\begin{itemize}
\tightlist
\item
  \texttt{event}: An \texttt{Event} protocol buffer.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.SummaryWriter.add\_graph(graph\_def,\ global\_step=None)}
}{tf.train.SummaryWriter.add\_graph(graph\_def, global\_step=None) }}\label{tf.train.summarywriter.addux5fgraphgraphux5fdef-globalux5fstepnone}

Adds a \texttt{GraphDef} protocol buffer to the event file.

The graph described by the protocol buffer will be displayed by
TensorBoard. Most users pass a graph in the constructor instead.

\subparagraph{Args: }\label{args-39}

\begin{itemize}
\tightlist
\item
  \texttt{graph\_def}: A \texttt{GraphDef} protocol buffer.
\item
  \texttt{global\_step}: Number. Optional global step counter to record
  with the graph.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.SummaryWriter.flush()}
}{tf.train.SummaryWriter.flush() }}\label{tf.train.summarywriter.flush}

Flushes the event file to disk.

Call this method to make sure that all pending events have been written
to disk.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.train.SummaryWriter.close()}
}{tf.train.SummaryWriter.close() }}\label{tf.train.summarywriter.close}

Flushes the event file to disk and close the file.

Call this method when you do not need the summary writer anymore.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.summary\_iterator(path)}
}{tf.train.summary\_iterator(path) }}\label{tf.train.summaryux5fiteratorpath}

An iterator for reading \texttt{Event} protocol buffers from an event
file.

You can use this function to read events written to an event file. It
returns a Python iterator that yields \texttt{Event} protocol buffers.

Example: Print the contents of an events file.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \NormalTok{e }\OperatorTok{in} \NormalTok{tf.summary_iterator(path to events }\BuiltInTok{file}\NormalTok{):}
    \BuiltInTok{print} \NormalTok{e}
\end{Highlighting}
\end{Shaded}

Example: Print selected summary values.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# This example supposes that the events file contains summaries with a}
\CommentTok{# summary value tag 'loss'.  These could have been added by calling}
\CommentTok{# `add_summary()`, passing the output of a scalar summary op created with}
\CommentTok{# with: `tf.scalar_summary(['loss'], loss_tensor)`.}
\ControlFlowTok{for} \NormalTok{e }\OperatorTok{in} \NormalTok{tf.summary_iterator(path to events }\BuiltInTok{file}\NormalTok{):}
    \ControlFlowTok{for} \NormalTok{v }\OperatorTok{in} \NormalTok{e.summary.value:}
        \ControlFlowTok{if} \NormalTok{v.tag }\OperatorTok{==} \StringTok{'loss'}\NormalTok{:}
            \BuiltInTok{print} \NormalTok{v.simple_value}
\end{Highlighting}
\end{Shaded}

See the protocol buffer definitions of
\href{https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/util/event.proto}{Event}
and
\href{https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/summary.proto}{Summary}
for more information about their attributes.

\subparagraph{Args: }\label{args-40}

\begin{itemize}
\tightlist
\item
  \texttt{path}: The path to an event file created by a
  \texttt{SummaryWriter}.
\end{itemize}

\subparagraph{Yields: }\label{yields}

\texttt{Event} protocol buffers.

\subsection{Training utilities }\label{training-utilities}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.global\_step(sess,\ global\_step\_tensor)}
}{tf.train.global\_step(sess, global\_step\_tensor) }}\label{tf.train.globalux5fstepsess-globalux5fstepux5ftensor}

Small helper to get the global step.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Creates a variable to hold the global_step.}
\NormalTok{global_step_tensor }\OperatorTok{=} \NormalTok{tf.Variable(}\DecValTok{10}\NormalTok{, trainable}\OperatorTok{=}\VariableTok{False}\NormalTok{, name}\OperatorTok{=}\StringTok{'global_step'}\NormalTok{)}
\CommentTok{# Creates a session.}
\NormalTok{sess }\OperatorTok{=} \NormalTok{tf.Session()}
\CommentTok{# Initializes the variable.}
\NormalTok{sess.run(global_step_tensor.initializer)}
\BuiltInTok{print} \StringTok{'global_step:'}\NormalTok{, tf.train.global_step(sess, global_step_tensor)}

\NormalTok{global_step: }\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-41}

\begin{itemize}
\tightlist
\item
  \texttt{sess}: A brain \texttt{Session} object.
\item
  \texttt{global\_step\_tensor}: \texttt{Tensor} or the \texttt{name} of
  the operation that contains the global step.
\end{itemize}

\subparagraph{Returns: }\label{returns-27}

The global step value.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.train.write\_graph(graph\_def,\ logdir,\ name,\ as\_text=True)}
}{tf.train.write\_graph(graph\_def, logdir, name, as\_text=True) }}\label{tf.train.writeux5fgraphgraphux5fdef-logdir-name-asux5ftexttrue}

Writes a graph proto on disk.

The graph is written as a binary proto unless as\_text is \texttt{True}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OperatorTok{=} \NormalTok{tf.Variable(}\DecValTok{0}\NormalTok{, name}\OperatorTok{=}\StringTok{'my_variable'}\NormalTok{)}
\NormalTok{sess }\OperatorTok{=} \NormalTok{tf.Session()}
\NormalTok{tf.train.write_graph(sess.graph_def, }\StringTok{'/tmp/my-model'}\NormalTok{, }\StringTok{'train.pbtxt'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-42}

\begin{itemize}
\tightlist
\item
  \texttt{graph\_def}: A \texttt{GraphDef} protocol buffer.
\item
  \texttt{logdir}: Directory where to write the graph.
\item
  \texttt{name}: Filename for the graph.
\item
  \texttt{as\_text}: If \texttt{True}, writes the graph as an ASCII
  proto.
\end{itemize}
