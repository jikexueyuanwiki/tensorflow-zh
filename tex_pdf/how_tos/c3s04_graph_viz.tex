

\section{TensorBoard: 图表可视化
}\label{tensorboard-ux56feux8868ux53efux89c6ux5316}

TensorFlow
图表计算强大而又复杂，图表可视化在理解和调试时显得非常有帮助。
下面是一个运作时的可式化例子。

\includegraphics{../images/graph_vis_animation.gif}
``一个TensorFlow图表的可视化'') \emph{一个TensorFlow图表的可视化。}

为了显示自己的图表，需将 TensorBoard
指向此工作的日志目录并运行，点击图表顶部窗格的标签页，然后在左上角的菜单中选择合适的运行。想要深入学习关于如何运行
TensorBoard 以及如何保证所有必要信息被记录下来，请查看
\href{tensorflow-zh/SOURCE/how_tos/summaries_and_tensorboard/index.md}{Summaries
和 TensorBoard}.

\subsection{名称域（Name scoping）和节点（Node）
}\label{ux540dux79f0ux57dfname-scopingux548cux8282ux70b9node}

典型的 TensorFlow
可以有数以千计的节点，如此多而难以一下全部看到，甚至无法使用标准图表工具来展示。为简单起见，我们为变量名划定范围，并且可视化把该信息用于在图表中的节点上定义一个层级。默认情况下，
只有顶层节点会显示。下面这个例子使用\href{tensorflow-zh/SOURCE/api_docs/python/framework.md\#name_scope}{\texttt{tf.name\_scope}}在\texttt{hidden}命名域下定义了三个操作:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \NormalTok{tensorflow }\ImportTok{as} \NormalTok{tf}

\ControlFlowTok{with} \NormalTok{tf.name_scope(}\StringTok{'hidden'}\NormalTok{) }\ImportTok{as} \NormalTok{scope:}
  \NormalTok{a }\OperatorTok{=} \NormalTok{tf.constant(}\DecValTok{5}\NormalTok{, name}\OperatorTok{=}\StringTok{'alpha'}\NormalTok{)}
  \NormalTok{W }\OperatorTok{=} \NormalTok{tf.Variable(tf.random_uniform([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{], }\OperatorTok{-}\FloatTok{1.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{), name}\OperatorTok{=}\StringTok{'weights'}\NormalTok{)}
  \NormalTok{b }\OperatorTok{=} \NormalTok{tf.Variable(tf.zeros([}\DecValTok{1}\NormalTok{]), name}\OperatorTok{=}\StringTok{'biases'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

结果是得到了下面三个操作名:

\begin{itemize}
\tightlist
\item
  \emph{hidden}/alpha
\item
  \emph{hidden}/weights
\item
  \emph{hidden}/biases
\end{itemize}

默认地，三个操作名会折叠为一个节点并标注为\texttt{hidden}。其额外细节并没有丢失，你可以双击，或点击右上方橙色的\texttt{+}来展开节点，然后就会看到三个子节点\texttt{alpha}，\texttt{weights}和\texttt{biases}了。

这有一个生动的例子，例中有一个更复杂的节点，节点处于其初始和展开状态。

\begin{verbatim}
<td style="width: 50%;">
  <img src="../images/pool1_collapsed.png" alt="未展开的名称域" title="未展开的名称域" />
</td>
<td style="width: 50%;">
  <img src="../images/pool1_expanded.png" alt="展开的名称域" title="展开的名称域" />
</td>
\end{verbatim}

\begin{verbatim}
<td style="width: 50%;">
  顶级名称域的初始视图<code>pool_1</code>，点击右上方橙色的<code>+</code>按钮或双击节点来展开。
</td>
<td style="width: 50%;">
  展开的<code>pool_1</code>名称域视图，点击右上方橙色的<code>-</code>按钮或双击节点来收起此名称域。
</td>
\end{verbatim}

通过名称域把节点分组来得到可读性高的图表很关键的。如果你在构建一个模型，名称域就可以用来控制可视化结果。\textbf{你的名称域越好，可视性就越好。}

上面的图像例子说明了可视化的另一方面， TensorFlow
图表有两种连接关系：数据依赖和控制依赖。数据依赖显示两个操作之间的tensor流程，用实心箭头指示，而控制依赖用点线表示。在已展开的视图(上面的右图)中，除了用点线连接的\texttt{CheckNumerics}和\texttt{control\_dependency}之外，所有连接都是数据依赖的。

还有一种手段用来简化布局。大多数 TensorFlow
图表有一部分节点，这部分节点和其他节点之间有很多连接。比如，许多节点在初始化阶段可能会有一个控制依赖，而绘制所有\texttt{init}节点的边缘和其依赖可能会创造出一个混乱的视图。

为了减少混乱，可视化把所有 high-degree
节点分离到右边的一个\emph{从属}区域，
而不会绘制线条来表示他们的边缘。线条也不用来表示连接了，我们绘制了小\emph{节点图标}来指示这些连接关系。分离出从属节点通常不会把关键信息删除掉，因为这些节点和内构功能是相关的。

\begin{verbatim}
<td style="width: 50%;">
  <img src="../images/conv_1.png" alt="conv_1是主图表的部分" title="conv_1是主图表的部分" />
</td>
<td style="width: 50%;">
  <img src="../images/save.png" alt="save被抽出为从属节点" title="save被抽出为从属节点" />
</td>
\end{verbatim}

\begin{verbatim}
<td style="width: 50%;">
  节点<code>conv_1</code>被连接到<code>save</code>，注意其右边<code>save</code>节点图标。
</td>
<td style="width: 50%;">
  <code>save</code> has a high degree, 并会作为从属节点出现，与<code>conv_1</code>的连接作为一个节点图标显示在其左边。为了继续减少杂乱，既然<code>save</code>有很多连接，我们则只显示前5个，而把其余的缩略为<code>... 12 more</code>。
</td>
\end{verbatim}

最后一个结构上的简化法叫做\emph{序列折叠（series collapsing）}。
序列基序（Sequential
motifs）是拥有相同结构并且其名称结尾的数字不同的节点，它们被折叠进一个单独的节点块（stack）中。对长序列网络来说，序列折叠极大地简化了视图，对于已层叠的节点，双击会展开序列。

\begin{verbatim}
<td style="width: 50%;">
  <img src="../images/series.png" alt="节点序列" title="节点序列" />
</td>
<td style="width: 50%;">
  <img src="../images/series_expanded.png" alt="展开的节点序列" title="展开的节点序列" />
</td>
\end{verbatim}

\begin{verbatim}
<td style="width: 50%;">
  一个节点序列的折叠视图。
</td>
<td style="width: 50%;">
  视图的一小块, 双击后展开。
</td>
\end{verbatim}

最后，针对易读性的最后一点要说到的是，可视化为常节点和摘要节点使用了特别的图标，总结起来有下面这些节点符号：

\begin{longtable}[c]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
符号
\strut\end{minipage} &
\begin{minipage}[b]{0.05\columnwidth}\raggedright\strut
意义
\strut\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
\includegraphics{../images/namespace_node.png}
\strut\end{minipage} &
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
\emph{High-level}节点代表一个名称域，双击则展开一个高层节点。
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
\includegraphics{../images/horizontal_stack.png}
\strut\end{minipage} &
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
彼此之间不连接的有限个节点序列。
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
\includegraphics{../images/vertical_stack.png}
\strut\end{minipage} &
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
彼此之间相连的有限个节点序列。
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
\includegraphics{../images/op_node.png}
\strut\end{minipage} &
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
一个单独的操作节点。
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
\includegraphics{../images/constant.png}
\strut\end{minipage} &
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
一个常量结点。
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
\includegraphics{../images/summary.png}
\strut\end{minipage} &
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
一个摘要节点。
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
\includegraphics{../images/dataflow_edge.png}
\strut\end{minipage} &
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
显示各操作间的数据流边。
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
\includegraphics{../images/control_edge.png}
\strut\end{minipage} &
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
显示各操作间的控制依赖边。
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
\includegraphics{../images/reference_edge.png}
\strut\end{minipage} &
\begin{minipage}[t]{0.05\columnwidth}\raggedright\strut
引用边，表示出度操作节点可以使入度tensor发生变化。
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\subsection{交互 }\label{ux4ea4ux4e92}

通过平移和缩放来导航图表，点击和拖动用于平移，滚动手势用于缩放。双击一个节点或点击其\texttt{+}按钮来展开代表一组操作的名称域。右下角有一个小地图可以在缩放和平移时方便的改变当前视角。

要关闭一个打开的节点，再次双击它或点击它的\texttt{-}按钮，你也可以只点击一次来选中一个节点，节点的颜色会加深，并且会看到节点的详情，其连接到的节点会在可视化右上角的详情卡片显现。

\begin{verbatim}
<td style="width: 50%;">
  <img src="../images/infocard.png" alt="一个名称域的详情卡片" title="一个名称域的详情卡片" />
</td>
<td style="width: 50%;">
  <img src="../images/infocard_op.png" alt="操作节点的详情卡片" title="操作节点的详情卡片" />
</td>
\end{verbatim}

\begin{verbatim}
<td style="width: 50%;">
  详情卡片展示<code>conv2</code>名称域的详细信息，名称域中操作节点的输入和输出被结合在一起，适用于不显示属性的名称域。
</td>
<td style="width: 50%;">
  详情卡片展示<code>DecodeRaw</code>操作节点，除了输入和输出，卡片也会展示与当前节点相关的设备和属性。
</td>
\end{verbatim}

选择对于 high-degree
节点的理解也很有帮助，选择任意节点，则与它的其余连接相应的节点也会选中，这使得在进行例如查看哪一个节点是否已保存等操作时非常容易。

点击详情卡片中的一个节点名称时会选中该节点，必要的话，视角会自动平移以使该节点可见。

最后，使用图例上方的颜色菜单，你可以给你的图表选择两个颜色方案。默认的\emph{结构视图}下，当两个
high-level
节点颜色一样时，其会以相同的彩虹色彩出现，而结构唯一的节点颜色是灰色。还有一个视图则展示了不同的操作运行于什么设备之上。名称域被恰当的根据其中的操作节点的设备片件来着色。

下图是一张真实图表的图解：

\begin{verbatim}
<td style="width: 50%;">
  <img src="../images/colorby_structure.png" alt="按结构着色" title="按结构着色" />
</td>
<td style="width: 50%;">
  <img src="../images/colorby_device.png" alt="按设备着色" title="按设备着色" />
</td>
\end{verbatim}

\begin{verbatim}
<td style="width: 50%;">
  结构视图：灰色节点的结构是唯一的。橙色的<code>conv1</code>和<code>conv2</code>节点有相同的结构, 其他颜色的节点也类似。
</td>
<td style="width: 50%;">
  设备视图：名称域根据其中的操作节点的设备片件来着色，在此紫色代表GPU，绿色代表CPU。
</td>
\end{verbatim}

原文:
\href{../images/index.html\#tensorboard-graph-visualization}{TensorBoard:
Graph Visualization} 翻译: {[}@Warln{]}(https://github.com/Warln) 校对:
\href{https://github.com/lucky521}{lucky521}
